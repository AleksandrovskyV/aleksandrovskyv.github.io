<!DOCTYPE html>
<html lang="ru"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="- взятая сканером" />

<meta property="og:title" content="графика">
<meta property="og:type" content="website">
<meta property="og:url" content="https://vsky.space/графика">
<meta property="og:description" content="- взятая сканером">
<meta property="og:image" content="https://vsky.space/content/cover/raphics.jpg">
<meta property="og:image:secure_url" content="https://vsky.space/content/cover/graphics.jpg">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="графика">
<meta name="twitter:description" content="- взятая сканером">
<meta name="twitter:image" content="https://vsky.space/content/cover/graphics.jpg">
<meta name="twitter:site" content="@AleksandrovskyV">

<title>графика</title>


<style>
html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
}

.viewport {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background:#eaeaea;
  touch-action: none;
  cursor:grab;
}

.viewport.grabbing {
  cursor: grabbing;
}

.board{
position:absolute;
width:5000px;
height:5000px;
transform-origin:0 0;
}

.block{
position:absolute;
mix-blend-mode: multiply; 
}

.image{
user-select:none;
pointer-events:auto;
}

.image img{
display:block;
width: 100%;
height: 100%;
border-radius:0px;
user-select: none;
-webkit-user-select: none;
-webkit-user-drag: none;

}

.drag img{
user-select: none;
-webkit-user-select: none;
-webkit-user-drag: none;
}
.drag:active {
  cursor: grabbing;
}

</style>
</head>

<body>
<div class="viewport" id="viewport">
<div class="board" id="board" >


<div class="block drag" style="left:7751px;  top:555.64px;"><img  src="/content/graphics/g1.png" style="width:207px; height:auto; "></div>
<div class="block drag" style="left:7978px;  top:556.64px;"><img  src="/content/graphics/g2.png" style="width:207px; height:auto; "></div>


</div>
</div>

<script>
const board = document.getElementById("board");
const viewport = document.getElementById("viewport");
const secretElements = document.querySelectorAll('[data-state="secret"]');

let offsetX = -1540;
let offsetY = 200;
let scale = 0.4;


/* =======================
   BOARD TRANSFORM
======================= */
function updateBoard() {
  board.style.transform = `translate(${offsetX}px,${offsetY}px) scale(${scale})`;
}

updateBoard();

/* =======================
   MOUSE – BOARD PAN
======================= */
let mousePanning = false;
let mouseStartX = 0;
let mouseStartY = 0;

viewport.addEventListener("mousedown", e => {
  if (e.target.closest(".block.drag")) return;
  if (e.target.closest(".text") || e.target.closest(".backcode")) return;

  mousePanning = true;
  viewport.classList.add("grabbing");

  mouseStartX = e.clientX - offsetX;
  mouseStartY = e.clientY - offsetY;
});



window.addEventListener("mousemove", e => {
  if (!mousePanning) return;
  offsetX = e.clientX - mouseStartX;
  offsetY = e.clientY - mouseStartY;
  updateBoard();
});

window.addEventListener("mouseup", () => {
  mousePanning = false;
  viewport.classList.remove("grabbing");
});

/* =======================
   MOUSE – BLOCK DRAG
======================= */
let dragItem = null;
let dragStartX = 0;
let dragStartY = 0;
let itemStartLeft = 0;
let itemStartTop = 0;

document.querySelectorAll(".block.drag").forEach(el => {
  el.addEventListener("mousedown", e => {
    e.stopPropagation();
    dragItem = el;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    itemStartLeft = parseFloat(el.style.left) || 0;
    itemStartTop  = parseFloat(el.style.top)  || 0;
  });
});

window.addEventListener("mousemove", e => {
  if (!dragItem) return;
  const dx = (e.clientX - dragStartX) / scale;
  const dy = (e.clientY - dragStartY) / scale;
  dragItem.style.left = itemStartLeft + dx + "px";
  dragItem.style.top  = itemStartTop  + dy + "px";
});

window.addEventListener("mouseup", () => {
  dragItem = null;
});

/* =======================
   MOUSE – WHEEL
======================= */
const blockState = new WeakMap();

viewport.addEventListener("wheel", e => {
  const block = e.target.closest(".block.drag");

  if (block) {
    e.preventDefault();
    if (!blockState.has(block)) {
      blockState.set(block, { scale: 1, rotation: 0 });
    }
    const state = blockState.get(block);
    state.rotation += e.deltaY > 0 ? 5 : -5;
    block.style.transform =
      `scale(${state.scale}) rotate(${state.rotation}deg)`;
    return;
  }

  e.preventDefault();
  const prevScale = scale;
  scale *= e.deltaY > 0 ? 0.9 : 1.1;
  scale = Math.min(Math.max(scale, 0.2), 4);

  const rect = viewport.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;

  offsetX = cx - (cx - offsetX) * (scale / prevScale);
  offsetY = cy - (cy - offsetY) * (scale / prevScale);
  updateBoard();
}, { passive: false });

/* =======================
   TOUCH HELPERS
======================= */
function dist(t) {
  const dx = t[0].clientX - t[1].clientX;
  const dy = t[0].clientY - t[1].clientY;
  return Math.hypot(dx, dy);
}

function angle(t) {
  return Math.atan2(
    t[1].clientY - t[0].clientY,
    t[1].clientX - t[0].clientX
  ) * 180 / Math.PI;
}

/* =======================
   TOUCH STATE
======================= */
let activeBlock = null;
let blockStartDist = 0;
let blockStartAngle = 0;
let blockStartScale = 1;
let blockStartRotation = 0;

let touchPan = false;
let panStartX = 0;
let panStartY = 0;

let pinchStartDist = 0;
let pinchStartScale = 1;
let pinchCenterX = 0;
let pinchCenterY = 0;
let pinchBoardX = 0;
let pinchBoardY = 0;

/* =======================
   TOUCHSTART
======================= */
viewport.addEventListener("touchstart", e => {
  const block = e.target.closest(".block.drag");

  if (block) {
    e.preventDefault();
    activeBlock = block;

    if (!blockState.has(block)) {
      blockState.set(block, { scale: 1, rotation: 0 });
    }
    const state = blockState.get(block);

    if (e.touches.length === 1) {
      dragItem = block;
      dragStartX = e.touches[0].clientX;
      dragStartY = e.touches[0].clientY;
      itemStartLeft = parseFloat(block.style.left) || 0;
      itemStartTop  = parseFloat(block.style.top)  || 0;
    }

    if (e.touches.length === 2) {
      blockStartDist = dist(e.touches);
      blockStartAngle = angle(e.touches);
      blockStartScale = state.scale;
      blockStartRotation = state.rotation;
    }
    return;
  }

  if (e.touches.length === 1) {
    touchPan = true;
    panStartX = e.touches[0].clientX - offsetX;
    panStartY = e.touches[0].clientY - offsetY;
  }

  if (e.touches.length === 2) {
    touchPan = false; 
    e.preventDefault();

    pinchStartDist = dist(e.touches);
    pinchStartScale = scale;

    pinchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    pinchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

    pinchBoardX = (pinchCenterX - offsetX) / scale;
    pinchBoardY = (pinchCenterY - offsetY) / scale;
  }
}, { passive: false });

/* =======================
   TOUCHMOVE
======================= */
viewport.addEventListener("touchmove", e => {

  if (activeBlock && e.touches.length === 2) {
    e.preventDefault();
    const state = blockState.get(activeBlock);
    state.scale = blockStartScale * (dist(e.touches) / blockStartDist);
    state.rotation = blockStartRotation + (angle(e.touches) - blockStartAngle);
    activeBlock.style.transform =
      `scale(${state.scale}) rotate(${state.rotation}deg)`;
    return;
  }

  if (dragItem && e.touches.length === 1) {
    e.preventDefault();
    const dx = (e.touches[0].clientX - dragStartX) / scale;
    const dy = (e.touches[0].clientY - dragStartY) / scale;
    dragItem.style.left = itemStartLeft + dx + "px";
    dragItem.style.top  = itemStartTop  + dy + "px";
    return;
  }

  if (touchPan && e.touches.length === 1) {
    e.preventDefault();
    offsetX = e.touches[0].clientX - panStartX;
    offsetY = e.touches[0].clientY - panStartY;
    updateBoard();
    return;
  }

  if (e.touches.length === 2 && pinchStartDist) {
    e.preventDefault();
    scale = pinchStartScale * (dist(e.touches) / pinchStartDist);
    scale = Math.min(Math.max(scale, 0.15), 4);
    const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;

    offsetX = cx - pinchBoardX * scale;
    offsetY = cy - pinchBoardY * scale;
    updateBoard();
  }
}, { passive: false });

/* =======================
   TOUCHEND
======================= */
viewport.addEventListener("touchend", e => {
  if (e.touches.length === 0) {
    dragItem = null;
    activeBlock = null;
    touchPan = false;
    pinchStartDist = 0;
  }
}, { passive: false });



// делаем все потенциальные элементы нефокусируемыми
document.querySelectorAll("a, .text, .backcode").forEach(el => {
  el.tabIndex = -1;
});

// ESC — как в "негативах"
function onKeyCommand(e) {
  if (e.key !== "Escape") return;

  e.preventDefault();
  e.stopPropagation();

  if (window.location.protocol === "file:") {
    window.location.href = "../index.html";
  } else {
    window.location.href = "https://vsky.space";
  }
}

window.addEventListener("keydown", onKeyCommand, { capture: true });

window.addEventListener("pointerdown", () => {
  window.focus();
});

</script>




</body></html>