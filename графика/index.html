<!DOCTYPE html>
<html lang="ru"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="- взятая сканером" />

<meta property="og:title" content="графика">
<meta property="og:type" content="website">
<meta property="og:url" content="https://vsky.space/графика">
<meta property="og:description" content="- взятая сканером">
<meta property="og:image" content="https://vsky.space/content/cover/raphics.jpg">
<meta property="og:image:secure_url" content="https://vsky.space/content/cover/graphics.jpg">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="графика">
<meta name="twitter:description" content="- взятая сканером">
<meta name="twitter:image" content="https://vsky.space/content/cover/graphics.jpg">
<meta name="twitter:site" content="@AleksandrovskyV">

<title>графика</title>

<style>
  html,body { width:100%;height:100%;margin:0;background:#dbd5d7; }
  #canvas { width:100%; height:100%; display:block; touch-action: none; cursor: grab; }
  #canvas.grabbing { cursor: grabbing; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false }); // alpha false slightly faster
  let dpr = Math.max(1, window.devicePixelRatio || 1);

  // === сцена / карточки (замени src на свои) ===
  const layersData = [
    { src: '/content/graphics/g1.png', x: 600, y: 150,  w: 600, h: null },
    { src: '/content/graphics/g2.png', x: 202, y: -50,    w: 600, h: null }
  ];

  // board/world размер — можно установить большой:
  const WORLD_W = 14000;
  const WORLD_H = 5000;

  // камера (в screen-пикселях)
  const camera = { x: 0, y: 0, scale: 1.0 };

  // загруженные изображения
  const layers = []; // {img, x,y,w,h,src}
  let imagesToLoad = layersData.length;
  let isReady = false;

  // хит-тест: будем проверять по прямоугольнику слоя
  function worldToScreen(wx, wy) {
    return {
      sx: wx * camera.scale + camera.x,
      sy: wy * camera.scale + camera.y
    };
  }
  function screenToWorld(sx, sy) {
    return {
      wx: (sx - camera.x) / camera.scale,
      wy: (sy - camera.y) / camera.scale
    };
  }

  // resize canvas
  function resize() {
    dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssW = canvas.clientWidth || innerWidth;
    const cssH = canvas.clientHeight || innerHeight;
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale for high DPI
    draw();
  }
  window.addEventListener('resize', resize);

  // load images
  layersData.forEach(ld => {
    const img = new Image();
    img.src = ld.src;
    img.onload = () => {
      // determine size: keep aspect ratio, if height null use natural
      const w = ld.w || img.naturalWidth;
      const h = ld.h || Math.round(img.naturalHeight * (w / img.naturalWidth));
      layers.push({ img, x: ld.x, y: ld.y, w, h, src: ld.src });
      imagesToLoad--;
      if (imagesToLoad === 0) {
        isReady = true;
        resize();
      }
    };
    img.onerror = () => {
      console.warn('img load error', ld.src);
      imagesToLoad--;
      if (imagesToLoad === 0) {
        isReady = true;
        resize();
      }
    };
  });

  // drawing loop (immediate draw)
  function draw() {
    // clear full canvas (in CSS px)
    ctx.save();
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // ensure device scaling
    ctx.fillStyle = '#dbd5d7'; // default base to avoid artifacts
    ctx.fillRect(0,0, canvas.width / dpr, canvas.height / dpr);

    if (!isReady) {
      // loading placeholder
      ctx.fillStyle = '#aaa';
      ctx.fillRect(0,0, canvas.width / dpr, canvas.height / dpr);
      ctx.fillStyle = '#000';
      ctx.fillText('Loading...', 20, 30);
      ctx.restore();
      return;
    }

    // apply camera transform (in CSS pixels)
    ctx.setTransform(camera.scale * dpr, 0, 0, camera.scale * dpr, camera.x * dpr, camera.y * dpr);

    // draw background of the world (this is the backdrop for multiply)
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = '#dbd5d7';
    // Draw a large rect covering world coords
    ctx.fillRect(-1000, -1000, WORLD_W + 3000, WORLD_H + 3000);

    // now draw layers with multiply
    ctx.globalCompositeOperation = 'multiply';
    for (let i = 0; i < layers.length; i++) {
      const L = layers[i];
      ctx.drawImage(L.img, L.x, L.y, L.w, L.h);
    }

    // restore to default
    ctx.globalCompositeOperation = 'source-over';

    // optionally draw outlines for debugging (screen-space)
    ctx.setTransform(1 * dpr, 0, 0, 1 * dpr, 0, 0);
    // draw camera debug rect
    // ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    // ctx.strokeRect(0,0, canvas.width/dpr, canvas.height/dpr);

    ctx.restore();
  }

  // Interaction: pan whole world vs drag layers
  let pointerDown = false;
  let lastPointer = { x: 0, y: 0 };
  let activeDrag = null; // {layer, offsetWx, offsetWy}
  let panning = false;

  function getTopLayerAtScreen(sx, sy) {
    const { wx, wy } = screenToWorld(sx, sy);
    // iterate from top (last drawn) to bottom
    for (let i = layers.length - 1; i >= 0; i--) {
      const L = layers[i];
      if (wx >= L.x && wx <= L.x + L.w && wy >= L.y && wy <= L.y + L.h) {
        return { L, idx: i };
      }
    }
    return null;
  }

  canvas.addEventListener('pointerdown', e => {
    e.preventDefault();
    canvas.setPointerCapture(e.pointerId);
    canvas.classList.add('grabbing');
    pointerDown = true;
    lastPointer.x = e.clientX;
    lastPointer.y = e.clientY;

    // determine if pointer hits a layer
    const hit = getTopLayerAtScreen(e.clientX, e.clientY);
    if (hit) {
      // start layer drag
      const { wx, wy } = screenToWorld(e.clientX, e.clientY);
      activeDrag = {
        layerIndex: hit.idx,
        offsetWx: wx - hit.L.x,
        offsetWy: wy - hit.L.y
      };
      panning = false;
    } else {
      // start panning
      panning = true;
      activeDrag = null;
    }
  });

  canvas.addEventListener('pointermove', e => {
    if (!pointerDown) return;
    const dx = e.clientX - lastPointer.x;
    const dy = e.clientY - lastPointer.y;
    lastPointer.x = e.clientX;
    lastPointer.y = e.clientY;

    if (activeDrag) {
      // move layer in world coords
      const { wx, wy } = screenToWorld(e.clientX, e.clientY);
      const L = layers[activeDrag.layerIndex];
      L.x = wx - activeDrag.offsetWx;
      L.y = wy - activeDrag.offsetWy;
      draw();
      return;
    }

    if (panning) {
      // update camera translation in screen pixels
      camera.x += dx;
      camera.y += dy;
      draw();
      return;
    }
  });

  canvas.addEventListener('pointerup', e => {
    pointerDown = false;
    activeDrag = null;
    panning = false;
    canvas.releasePointerCapture(e.pointerId);
    canvas.classList.remove('grabbing');
  });

  // wheel -> zoom (centered on cursor)
  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    if (!isReady) return;

    const wheel = e.deltaY;
    const zoomFactor = wheel > 0 ? 0.92 : 1.08;
    // screen point
    const sx = e.clientX;
    const sy = e.clientY;
    // world point under cursor before zoom
    const before = screenToWorld(sx, sy);

    // apply zoom
    const newScale = Math.min(Math.max(camera.scale * zoomFactor, 0.15), 4);

    camera.scale = newScale;

    // recompute camera.x,y so that before world point remains under cursor
    camera.x = sx - before.wx * camera.scale;
    camera.y = sy - before.wy * camera.scale;

    draw();
  }, { passive: false });

  // touch pinch could be added — omitted for brevity

  // initial camera placement (optional)
  camera.x = window.innerWidth / 2 - 700 * camera.scale; // center-ish
  camera.y = window.innerHeight / 2 - 300 * camera.scale;

  // kickoff
  resize();
})();



// ESC — как в "негативах"
function onKeyCommand(e) {
  if (e.key !== "Escape") return;

  e.preventDefault();
  e.stopPropagation();

  if (window.location.protocol === "file:") {
    window.location.href = "../index.html";
  } else {
    window.location.href = "https://vsky.space";
  }
}

window.addEventListener("keydown", onKeyCommand, { capture: true });

window.addEventListener("pointerdown", () => {
  window.focus();
});

</script>
</body>
</html>
