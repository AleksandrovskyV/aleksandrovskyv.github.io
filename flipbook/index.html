<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  
  <meta name="description" content="Type to Flip? Flip and Type!" />
  <meta property="og:title" content="flipbook">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://vsky.space/flipbook">
  <meta property="og:description" content="Type to Flip? Flip and Type!">
  <meta property="og:image" content="https://vsky.space/content/cover/flipbook.jpg">
  <meta property="og:image:secure_url" content="https://vsky.space/content/cover/flipbook.jpg">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="flipbook">
  <meta name="twitter:description" content="Type to Flip? Flip and Type!">
  <meta name="twitter:image" content="https://vsky.space/content/cover/flipbook.jpg">
  <meta name="twitter:site" content="@AleksandrovskyV">

  <title>Flip...</title>
  <link rel="icon" href="/content/fav/f_book.png" type="image/png">
  <link rel="apple-touch-icon" sizes="180x180" href="/content/fav/f_book.png">

  <style>
    :root { --bg: #000; --ui: #000; --border: #222; --active: #fff; --accent: #ff8c00; }
    html,body { height:100%; margin:0; }
    body { background:var(--bg); color:#fff; font-family:system-ui, -apple-system, sans-serif; display:flex; align-items:center; justify-content:center; user-select:none; overflow:hidden; }
    #root { width:100vw; height:100vh; display:flex; align-items:center; justify-content:center; }
    canvas { image-rendering: pixelated; background:#000; display:block; }
    input[type=file] { display:none; }
  
    #mobileOverlay {
      display: none;
    }

    @media (max-width: 768px) {
      #mobileOverlay {
        position: fixed;
        inset: 0;
        background: #000;
        color: #666;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        font-family: system-ui, -apple-system, sans-serif;
        font-size: 24px;
        z-index: 9999;
        padding: 20px;
      }

      body {
        overflow: hidden;
      }
    }
</style>


</head>
<body>
  <div id="root">
    <canvas id="uiCanvas"></canvas>
    <div id="mobileOverlay">Only for Desktop..</div>
  </div>


  <input id="fileInput" type="file" accept="application/json" />
<script>

// flipbook.. flippook...
// Type? Flip? Flip & Type !

// Variables 
let _rafId = null;
let _loopPausedByVisibility = false;

let player = null, goal = null, isGameOver = false;
let isFrameGame = false;
let debug = false;

let curGfx = 0, curAnim = 0, isDrawing = false, drawMode = true, isPlaying = true, isInitialized = true;
let lastT = 0, fIdx = 0;
let mouseDown = false;

const AppStates = { INTRO: 0, FIRST_RESET: 1, FIRST_DRAW: 2, FIRST_PLAY: 3
};

const GameStates = { FIRST_SPAWN: 0, GOAL_SPAWN: 1, OPEN_GAME: 2,
};

let currentAppState = AppStates.INTRO;
let currentGameState = GameStates.FIRST_SPAWN;

// Frame Area setup : Default
const DEFAULTS_SETUP = {
    config: { rows: 7, cols: 10, size: 40 },
    states: [{ offsetX: 0, offsetY: 0, animStates: [{ activeCells: [], delay: 80 }] }]
};

// Frame Area setup : Preview on load page
const INITIAL_SETUP = {
  "config": { "rows": 7, "cols": 15, "size": 40
  },
  "graphicStates": [
    {
      "offsetX": 0, "offsetY": 0,
      "animStates": [
        { "activeCells": ["1,1","2,1","4,3","5,4","6,2","8,2","9,4","10,2","12,4","10,1","12,2","13,3","12,3","13,1","1,5","1,4","13,5","8,4","10,4","0,1","1,3","4,1","4,2","5,5","6,3","6,1","8,1","8,3","10,3","12,5","12,1","14,1","14,5","14,3","8,5","9,1","6,4","4,4","1,2"], "delay": 140 },
        { "activeCells": ["1,1","2,1","4,3","5,4","6,2","8,2","9,4","10,2","12,4","10,1","12,2","13,3","12,3","13,1","1,5","1,4","13,5","8,4","10,4","0,1","1,3","4,1","4,2","5,5","6,3","6,1","8,1","8,3","10,3","12,5","12,1","14,1","14,5","14,3","8,5","9,1","6,4","4,4"], "delay": 140 },
        { "activeCells": ["1,1","2,1","4,3","5,4","6,2","8,2","9,4","10,2","12,4","10,1","12,2","13,3","12,3","13,1","1,5","1,4","13,5","8,4","10,4","0,1","1,3","4,1","4,2","5,5","6,3","6,1","8,1","8,3","10,3","12,5","12,1","14,1","14,5","14,3","8,5","9,1","6,4"], "delay": 140 },
        { "activeCells": ["2,1","4,3","5,4","6,2","8,2","9,4","10,2","12,4","10,1","12,2","13,3","12,3","13,1","1,5","13,5","8,4","10,4","4,1","4,2","5,5","6,3","6,1","8,1","8,3","10,3","12,5","12,1","14,1","14,5","14,3","8,5","9,1"], "delay": 140 },
        { "activeCells": ["4,3","5,4","6,2","8,2","9,4","10,2","12,4","10,1","12,2","13,3","12,3","13,1","13,5","8,4","10,4","4,1","4,2","5,5","6,3","6,1","8,1","8,3","10,3","12,5","12,1","14,1","14,5","14,3","8,5"], "delay": 140 },
        { "activeCells": ["5,4","6,2","8,2","9,4","10,2","12,4","10,1","12,2","13,3","12,3","13,1","13,5","8,4","10,4","5,5","6,3","6,1","8,1","8,3","10,3","12,5","12,1","14,1","14,5","14,3"], "delay": 140 },
        { "activeCells": ["6,2","8,2","9,4","10,2","12,4","10,1","12,2","13,3","12,3","13,1","13,5","8,4","10,4","6,3","6,1","8,1","8,3","10,3","12,5","12,1","14,1","14,5"], "delay": 140 },
        { "activeCells": ["9,4","10,2","12,4","10,1","12,2","13,3","12,3","13,1","13,5","8,4","10,4","10,3","12,5","12,1","14,1"], "delay": 140 },
        { "activeCells": ["10,2","12,4","10,1","12,2","13,3","12,3","13,1","13,5","10,3","12,5","12,1"], "delay": 140 },
        { "activeCells": ["12,4","12,2","13,3","12,3","13,1","13,5","12,5"], "delay": 140 },
        { "activeCells": ["12,2","12,3","13,1"], "delay": 140 },
        { "activeCells": ["12,2","12,3"], "delay": 140 },
        { "activeCells": [], "delay": 140 }
      ]
    },
    {
      "offsetX": 0, "offsetY": 0,
      "animStates": [
        { "activeCells": ["0,1","1,1","2,1","0,2","0,3","0,4","0,5","1,3","2,2","4,1","4,2","4,3","4,4","4,5","5,5","6,5","8,1","8,2","8,3","8,4","8,5","9,1","10,1","10,2","10,3","10,4","10,5","9,3","12,1","12,2","12,3","14,3","14,1","14,2","13,4","13,5","12,4","14,4"], "delay": 140 },
        { "activeCells": ["0,1","1,1","2,1","0,2","0,3","0,4","0,5","1,3","2,2","4,1","4,2","4,3","4,4","4,5","5,5","6,5","8,1","8,2","8,3","8,4","8,5","9,1","10,1","10,2","10,3","10,4","10,5","9,3","12,1","12,2","12,3","14,3","14,1","14,2","13,4","13,5","12,4"], "delay": 140 },
        { "activeCells": ["0,1","1,1","2,1","0,2","0,3","0,4","0,5","1,3","2,2","4,1","4,2","4,3","4,4","4,5","5,5","6,5","8,4","8,5","9,1","10,1","10,2","10,3","10,4","10,5","9,3","12,1","12,2","12,3","14,3","14,1","14,2","13,4","13,5"], "delay": 140 },
        { "activeCells": ["0,1","1,1","2,1","0,2","0,3","0,4","0,5","1,3","2,2","4,1","4,2","4,3","4,4","4,5","5,5","6,5","8,4","8,5","9,1","12,1","12,2","12,3","14,3","14,1","14,2","13,4"], "delay": 140 },
        { "activeCells": ["0,1","1,1","2,1","0,2","0,3","0,4","0,5","1,3","2,2","4,4","4,5","5,5","6,5","8,4","8,5","9,1","12,1","12,2","12,3","14,3","14,1","14,2"], "delay": 140 },
        { "activeCells": ["0,1","1,1","2,1","0,2","0,3","0,4","0,5","1,3","2,2","4,4","4,5","5,5","6,5","8,4","8,5","9,1","14,3","14,1"], "delay": 140 },
        { "activeCells": ["0,1","1,1","2,1","0,2","0,3","0,4","0,5","1,3","2,2","4,4","4,5","5,5","6,5","8,4","8,5"], "delay": 140 },
        { "activeCells": ["0,1","1,1","2,1","0,2","0,3","0,4","0,5","1,3","2,2","4,4","4,5"], "delay": 140 },
        { "activeCells": ["0,1","1,1","2,1","0,2","0,3","0,4","0,5"], "delay": 140 },
        { "activeCells": ["0,1","1,1","2,1"], "delay": 140 },
        { "activeCells": ["0,1","1,1"], "delay": 140 },
        { "activeCells": ["0,1"], "delay": 140 },
        { "activeCells": [], "delay": 140 }
      ]
    }
  ]
};

let config = JSON.parse(JSON.stringify(INITIAL_SETUP.config));
let graphicStates = JSON.parse(JSON.stringify(INITIAL_SETUP.graphicStates));
let CELL = config.size;

//   Canvas UI primitives
const canvas = document.getElementById('uiCanvas');
const ctx = canvas.getContext('2d');
const fileInput = document.getElementById('fileInput');

function sizeCanvas() {
  const S = config.size;
  const leftW = S; 
  const rightW = S;
  const topH = S; 
  const timelineH = S; 
  const playH = S;

  const editorW = config.cols * S;
  const editorH = config.rows * S;

  canvas._layout = {
    leftW,rightW,
    topH,timelineH,playH,editorW,editorH,
    width: leftW + S + editorW +S + rightW,
    height: topH + S + editorH +S + timelineH + S + playH 
  };

  canvas.width = canvas._layout.width;
  canvas.height = canvas._layout.height;
  canvas.style.width = canvas.width + "px";
  canvas.style.height = canvas.height + "px";
}
sizeCanvas();


let lockinitAreaTut = false;
let tutorialOffset = false;
let tutorialResize = false;
let tutorialAFrObj = false;
let tutorialOffsetLock = false;
let completeAreaTutorial = false;

function initAreaTutorial(){
  tutorialOffset = false;
  tutorialResize = false;
  tutorialAFrObj = false;
  lockinitAreaTut = true;
}

function checkTutorial(){
  //console.log("TUTORIAL",tutorialOffset,tutorialResize,tutorialAFrObj);

  if(completeAreaTutorial){
    timelineArea.plusBtn.status = 1;
    timelineArea.minusBtn.status = 1;
    return
  }

  if(tutorialOffset ){
    //unlockObjectButtons = true;
      aCols.status = 1;
      //aRows.status = 1;
  }

  if(tutorialResize){
    unlockObjectButtons = true;
    aCols.status = 4;
    aRows.status = 4;
  }

  if(tutorialOffset && tutorialResize && tutorialAFrObj){
    completeAreaTutorial = true;
    tutorialOffsetLock = true;    
    baseButton.status = 1;
    return
  }

  if(!completeAreaTutorial && !lockinitAreaTut){
    
    baseButton.status = 4;
    initAreaTutorial();
  }  
}

/* Generic Base classes on cell grid */

const POSITION_BASED = 1;

class UIButton {
  constructor(text, onClick, { S = 1, D = 0, opts = {} } = {}) {
    this.text = text;
    this.onClick = onClick;

    this.status = 1; //opts.status ?? 1; 
    this.collision = true; //opts.collision ?? false;
    this.meta = opts.meta ?? null;

    this.S = S;
    this.D = D;

    this.x = 0; this.y = 0;
    this.w = 0; this.h = 0;

  }

  setCellPos(cellX, cellY) { // // Enter 1-based ?
      const cell = CELL;

      this.x = (cellX - 1) * cell;
      this.y = (cellY - 1) * cell;

      if (this.D === 0) {
          this.w = this.S * cell;
          this.h = cell;
      } else {
          this.w = cell;
          this.h = this.S * cell;
      }
  }

  setText(text) {
    this.text = text;
  }

  setLength(S) {
    this.S = S;
  }

  occupiesCell(cellX, cellY) { // Enter 1-based
    const startCellX = Math.floor(this.x / CELL) +POSITION_BASED; 
    const startCellY = Math.floor(this.y / CELL) +POSITION_BASED;

    const wCells = Math.round(this.w / CELL);
    const hCells = Math.round(this.h / CELL);
    return cellX >= startCellX && cellX < startCellX + wCells &&
           cellY >= startCellY && cellY < startCellY + hCells;

  }

  contains(px,py){
    return px >= this.x && py >= this.y &&
           px < this.x + this.w &&
           py < this.y + this.h;
  }

  render(ctx){
    // DISABLED
    if (this.status === 0){
      ctx.fillStyle = "#111";
      ctx.fillRect(this.x,this.y,this.w,this.h);
      ctx.strokeStyle = "#222";
      ctx.strokeRect(this.x+0.5,this.y+0.5,this.w-1,this.h-1);
      ctx.fillStyle = "#444";
    }
    // SELECTED (FULL FILL)
    else if (this.status === 2){
      ctx.fillStyle = "#fff";
      ctx.fillRect(this.x,this.y,this.w,this.h);
      ctx.fillStyle = "#000";
    }
    // NORMAL (NOT ACTIVE)
    else {
      ctx.fillStyle = "#000";
      ctx.fillRect(this.x,this.y,this.w,this.h);
      ctx.strokeStyle = "#222";
      ctx.strokeRect(this.x+0.5,this.y+0.5,this.w-1,this.h-1);
      ctx.fillStyle = "#ccc";
    }

    if (this.text !== ""){
      ctx.font = Math.floor(this.h * 0.5) + "px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      if (this.status === 4){
        ctx.fillStyle = "#222";
      }
      ctx.fillText(this.text, this.x + this.w/2, this.y + this.h/2 + 1);
    }
  }
}

class UISpacer {
  constructor(S = 1){
    this.S = S;
    this.isSpacer = true;
    this.x = this.y = this.w = this.h = 0;
  }

  contains(){ return false; }
  render(){}
}

class ButtonGroup {
  constructor(cellX, cellY, cellLen, items, direction = 0) {
    this.cx = cellX-1;       // координата в ячейках // преобразуем 1-based → 0-based
    this.cy = cellY-1;
    this.len = cellLen;    // сколько ячеек занимает вся панель
    this.items = items;
    this.dir = direction;  // 0=гор, 1=верт
  }

  rebuild() {
    const cell = CELL;

    const px = this.cx * cell;
    const py = this.cy * cell;
    const pixelLen = this.len * cell;

    let staticUnits = 0;
    let spacers = [];

    for (const b of this.items) {
      if (b.isSpacer) spacers.push(b);
      else staticUnits += b.S;
    }

    let freeUnits = Math.max(0, this.len - staticUnits);
    let each = spacers.length > 0 ? Math.floor(freeUnits / spacers.length) : 0;

    for (const sp of spacers) sp.S = each;

    // позиционирование
    let offset = 0;
    for (const b of this.items) {
      const size = b.S * cell;

      if (this.dir === 0) {
        b.x = px + offset;
        b.y = py;
        b.w = size;
        b.h = cell;
      } else {
        b.x = px;
        b.y = py + offset;
        b.w = cell;
        b.h = size;
      }

      offset += size;
      
    }
  }

  render(ctx) { this.items.forEach(b => b.render(ctx)); }
  find(px, py) { return this.items.find(b => b.contains(px, py)); }
}


/* Special Wrappers */
let unlockObjectButtons = false;
class ObjectArea {
  constructor(cellX, cellY, rows) {
    this.cx = cellX;
    this.cy = cellY;
    this.rows = rows;
    this.group = null;
    this.spacer = new UISpacer();
    this.plusBtn = new UIButton("+", addGfx, { S:1, D:1 })
  }

  rebuild() {
    let list = [];

    // графические фреймы
    for (let i=0; i < graphicStates.length; i++) {
      let btn = new UIButton(
        "",
        () => { curGfx = i; curAnim = 0; fIdx = 0; isPlaying = false; updateUIState(); },
        { S:1, D:1 }
      );
      btn.meta = { gfxIndex: i };
      list.push(btn);
    }

    list.push(this.spacer);
    list.push(this.plusBtn);

    this.group = new ButtonGroup(this.cx, this.cy, this.rows, list, 1);
    this.group.rebuild();
  }

  // Метод для обновления координат и размеров
  update(cellX, cellY, rows) {
    this.cx = cellX;
    this.cy = cellY;
    this.rows = rows;
    this.refresh(); // Обновляем только параметры
  }

  refresh() {
    // 1. Создаем новый список только для графических фреймов
    let newList = [];
    
    for (let i = 0; i < graphicStates.length; i++) {
      let btn = new UIButton(
        "",
        () => { curGfx = i; curAnim = 0; fIdx = 0; isPlaying = false; updateUIState(); },
        { S: 1, D: 1 }
      );
      btn.meta = { gfxIndex: i };
      newList.push(btn);
    }

    newList.push(this.spacer);
    newList.push(this.plusBtn);

    // 3. Обновляем данные в существующей группе
    if (this.group) {
      this.group.cx = this.cx; // Передаем новые координаты, если они изменились
      this.group.cy = this.cy;
      this.group.len = this.rows; // ButtonGroup ожидает поле len (кол-во ячеек)
      
      this.group.items = newList; // <- правильно: items, а не list
      this.group.rebuild();
    }
  }

  render(ctx) {
      for (const b of this.group.items) {

        if(unlockObjectButtons){
          b.status = 1;   // кнопка + или −
        }else{
          b.status = 4;  // блоикируем без подсветки
        }
        
        // активный
        if (b.meta?.gfxIndex === curGfx)
            b.status = 2;

        b.render(ctx);
      }
  }

  find(px,py) { return this.group.find(px,py); }
}


class EditorArea {
  constructor(cellX, cellY) {
    this.cx = cellX-1; 
    this.cy = cellY-1;
    this.updateSize();
  }

  updateSize() {
    this.S = CELL;
    this.x = this.cx * this.S;
    this.y = this.cy * this.S;
    this.w = config.cols * this.S;
    this.h = config.rows * this.S;
  }

  contains(px, py) {
    return px >= this.x && py >= this.y && px < this.x + this.w && py < this.y + this.h;
  }

  getPosFromCanvas(px, py) {
    if (!this.contains(px, py)) return null;
    const localX = Math.floor((px - this.x) / this.S);
    const localY = Math.floor((py - this.y) / this.S);
    // clamp to [0..cols-1] / [0..rows-1]
    const cx = Math.max(0, Math.min(config.cols - 1, localX));
    const cy = Math.max(0, Math.min(config.rows - 1, localY));
    return { x: cx, y: cy };
  }

  // рендерим ТОЛЬКО клетки, которые внутри editor (фильтруем graphicStates)
  render(ctx) {
    ctx.fillStyle = "#000";
    ctx.fillRect(this.x, this.y, this.w, this.h);
    ctx.strokeStyle = "#222";
    ctx.strokeRect(this.x + 0.5, this.y + 0.5, this.w - 1, this.h - 1);

    // grid
    ctx.strokeStyle = "#222";
    for (let i = 0; i <= config.cols; i++) {
      ctx.beginPath();
      ctx.moveTo(this.x + i * this.S, this.y);
      ctx.lineTo(this.x + i * this.S, this.y + config.rows * this.S);
      ctx.stroke();
    }
    for (let j = 0; j <= config.rows; j++) {
      ctx.beginPath();
      ctx.moveTo(this.x, this.y + j * this.S);
      ctx.lineTo(this.x + config.cols * this.S, this.y + j * this.S);
      ctx.stroke();
    }

    // draw only visible cells from current frame (clip)
    const gfx = graphicStates[curGfx];
    if (!gfx || !gfx.animStates[curAnim]) return;
    ctx.fillStyle = "#fff";
    gfx.animStates[curAnim].activeCells.forEach(key => {
      const [cx, cy] = key.split(',').map(Number); // these are 0-based in your data
      if (cx >= 0 && cx < config.cols && cy >= 0 && cy < config.rows) {
        ctx.fillRect(this.x + cx * this.S, this.y + cy * this.S, this.S, this.S);
      }
    });
  }
}


class TimelineArea {
   // не используем группу для позиционирования, вручную задаем параметры для начальной и конечной кнопки 
  constructor(cellX, cellY, cols, cellSize) {
    this.cx = (cellX-1)*cellSize;
    this.cy = (cellY-1)*cellSize;
    this.cols = cols;
    this.cellSize = cellSize; 
    this.group = { items: [] };

    // вынес т.к. нужны ссылки (хранить состояние)
    this.minusBtn = new UIButton("−", popAnim);
    this.plusBtn = new UIButton("+", addAnim);
    
    // на инициализации - неактивны
    this.plusBtn.status = 4;
    this.minusBtn.status = 4;

    // track previous state to refresh only when necessary
    this._lastGfxIndex = -1;
    this._lastFrameCount = 0;

  }

  rebuild() {
    const list = [];

    // кнопка минус
    this.minusBtn.x = this.cx; this.minusBtn.y = this.cy;
    this.minusBtn.w = this.cellSize; this.minusBtn.h = this.cellSize;
    
    list.push(this.minusBtn);

    const frames = graphicStates[curGfx].animStates;
    const frameCount = frames.length;
    const frameAreaW = this.cols * this.cellSize - this.cellSize * 2;
    const per = frameAreaW / frameCount;

    for (let i = 0; i < frameCount; i++) {
      const btn = new UIButton(
        "",
        () => { curAnim = i; fIdx = i; isPlaying = false; },
        { S: 1 } 
      );
      btn.meta = { frameIndex: i };

      btn.x = this.cx + this.cellSize + i * per;
      btn.y = this.cy;
      btn.w = per;
      btn.h = this.cellSize;

      list.push(btn);
    }

    // кнопка плюс
    this.plusBtn.x = this.cx + this.cellSize + frameAreaW; this.plusBtn.y = this.cy;
    this.plusBtn.w = this.cellSize; this.plusBtn.h = this.cellSize;

    list.push(this.plusBtn);

    this.group.items = list; 
  }

  // Метод для обновления координат и размеров
  update(cellX, cellY, cols, cellSize) {
    this.cx = (cellX - 1) * cellSize;
    this.cy = (cellY - 1) * cellSize;
    this.cols = cols;
    this.cellSize = cellSize;
    this.refresh(); // Обновляем только параметры
  }

  refresh() {
    if (this.cellSize === 0) return;

    // 1. Обновляем постоянную кнопку Минус
    this.minusBtn.x = this.cx; 
    this.minusBtn.y = this.cy;
    this.minusBtn.w = this.cellSize; 
    this.minusBtn.h = this.cellSize;

    const frames = graphicStates[curGfx].animStates;
    const frameCount = frames.length;
    const frameAreaW = this.cols * this.cellSize - this.cellSize * 2;
    const per = frameAreaW / frameCount;

    // 2. Фреймы (их кол-во меняется, поэтому пересоздаем только этот список)
    const frameButtons = [];
    for (let i = 0; i < frameCount; i++) {
      const btn = new UIButton("", () => { 
        curAnim = i; fIdx = i; isPlaying = false; 
      }, { S: 1 });
      btn.meta = { frameIndex: i };
      btn.x = this.cx + this.cellSize + i * per;
      btn.y = this.cy;
      btn.w = per;
      btn.h = this.cellSize;
      frameButtons.push(btn);
    }

    // 3. Обновляем постоянную кнопку Плюс
    this.plusBtn.x = this.cx + this.cellSize + frameAreaW; 
    this.plusBtn.y = this.cy;
    this.plusBtn.w = this.cellSize; 
    this.plusBtn.h = this.cellSize;

    // Собираем итоговый массив для рендера и поиска
    this.group.items = [this.minusBtn, ...frameButtons, this.plusBtn];
  }

  occupiesCell(cellX, cellY) {
    // переводим пиксельные координаты в 1-based клетки
    const startCellX = Math.floor(this.cx / this.cellSize) + 1;
    const rowY = Math.floor(this.cy / this.cellSize) + 1;

    return (
      cellY === rowY &&
      cellX >= startCellX &&
      cellX < startCellX + this.cols
    );
  }

  render(ctx) {
    //console.log("Отрисовка элементов:", this.group.items.length); // Сколько всего элементов?
    for (const b of this.group.items) {
      if (b.meta?.frameIndex !== undefined)
        b.status = (b.meta.frameIndex === curAnim) ? 2 : 1;
      //else
        //b.status = 1; // + и − кликабельны
      b.render(ctx);
    }
  }

  find(px, py) {
    return this.group.items.find(b => b.contains(px, py));
  }
}

//Build UI areas & buttons
let topToolbarArea, editorArea, objectArea, timelineArea, rightToolbarArea;

const loadButton     = new UIButton("□", ()=>fileInput.click(), { S:3 }); // LOAD
const spacerA        = new UISpacer();
const mLeft  = new UIButton("\u{25C0}\u{FE0E}",  () => shiftPixels(-1, 0)); // ◀
const mUp    = new UIButton("\u{25B2}\u{FE0E}",  () => shiftPixels(0, -1)); // ▲
const mDown  = new UIButton("\u{25BC}\u{FE0E}",  () => shiftPixels(0, 1));  // ▼
const mRight = new UIButton("\u{25B6}\u{FE0E}",  () => shiftPixels(1, 0));  // ▶
const spacerB        = new UISpacer();
const saveButton     = new UIButton("■", exportJSON, { S:3 }); // SAVE

saveButton.status = 4;

const topButtonsGroup = [
  loadButton, // spacerA, - для добавления нужно реализовать логику при нечетной разницы
  mLeft, mUp, mDown, mRight,
  spacerB, saveButton
];

const aCols = new UIButton("+", () => resizeGrid({ dc: 1 }));
const sCols = new UIButton("-", () => resizeGrid({ dc: -1 }));
const spacerR = new UISpacer();
const sRows = new UIButton("-", () => resizeGrid({ dr: -1 }));
const aRows = new UIButton("+", () => resizeGrid({ dr: 1 }));

const rightButtonsGroup = [
  aCols, sCols,
  spacerR,
  sRows, aRows
];

mLeft.status = 4; mUp.status = 4;
mDown.status = 4; mRight.status = 4;

aCols.status = 4; sCols.status = 4;
sRows.status = 4; aRows.status = 4;

const baseButton = new UIButton("\u{2716}\u{FE0E}", baseButtonAction, { S:4 }); // ✖ RESET
baseButton.status = 1;

let gameButton = null;
if(currentGameState === GameStates.OPEN_GAME){
  gameButton = new UIButton("⏯\u{FE0E}", gameButtonAction, { S:4 })
}


function rebuildLayout() {
  const cols = config.cols;   // ширина редактора в ячейках
  const rows = config.rows;   // высота редактора в ячейках
  const size = config.size; // CELL SIZE

  //// EditorArea:
  editorX = 3; editorY = 3;
  editorArea = new EditorArea(editorX, editorY);

  endEditorX = editorX + cols;
  endEditorY = editorY + rows;

  // !!  занять первую ячейку по x это x=1 !!!
  // x,y, length, buttons array, direction

  // Верхняя панель  
  topToolbarY = editorY-2;    
  topToolbarArea = new ButtonGroup(editorX,topToolbarY,cols,topButtonsGroup,0);

  // Левая панель (Objects Selector) 
  if(!objectArea){
    objectArea = new ObjectArea(1,editorY,rows);
  }else{
    //objectArea.rebuild();
    objectArea.update(1,editorY,rows);
    console.log("UPDATE_OBJECTLINE");
  }
  
  // Нижняя панель
  timelineY = endEditorY + 1;

  if(!timelineArea){
    timelineArea = new TimelineArea(
      editorX,
      timelineY,   // y под редактором
      cols,
      size
    );
  }else{
    // если просто пытаюсь обратиться через timelineArea.rebuild() - не высчитывает размер;
    timelineArea.update(
      editorX,
      timelineY,   // y под редактором
      cols,
      size
    );

    console.log("UPDATE_TIMELINE");
  }

  // Правая панель
  rightToolbarArea = new ButtonGroup(
    endEditorX + 1,  // справа от редактора через ячейку
    editorY,         // сверху на 3-й ячейке
    rows,            // высота панели
    rightButtonsGroup,
    1              // вертикаль
  );

  // подкнопка

  if(currentGameState !=  GameStates.OPEN_GAME){
    if(cols%2==1){
      baseButton.setLength(3);
      baseButton.setCellPos(1.5+cols/2, timelineY+2); 
    }else{
      baseButton.setLength(4);
      baseButton.setCellPos(1+cols/2, timelineY+2);
    }
  }else{
      if(gameButton){
        gameButton.setLength(3);
        gameButton.setCellPos(editorX, timelineY+2); 
      }
      baseButton.setLength(3);
      baseButton.setCellPos(endEditorX-3, timelineY+2); 
  }

  topToolbarArea.rebuild();
  rightToolbarArea.rebuild();

  if (timelineArea) {
    timelineArea._lastGfxIndex = curGfx;
    timelineArea._lastFrameCount = graphicStates[curGfx]?.animStates?.length || 0;
  }

  updateUIState();
}

function updateUIState(){
  objectArea.rebuild();
  timelineArea.rebuild();
}

function clear() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
}


function renderEntities(ctx){
  pb = POSITION_BASED; //1-based

  if (player){
    ctx.fillStyle = "#ff8c00";
    ctx.fillRect((player.x - pb)  * config.size,
                 (player.y - pb) * config.size,
                 config.size, config.size);
  }
  if (goal){
    ctx.fillStyle = "#00bfff";
    ctx.fillRect((goal.x - pb) * config.size,
                 (goal.y - pb) * config.size,
                 config.size, config.size);

  }
}


function renderAll() {
  clear();

  const L = canvas._layout;

  if(debug){
    ctx.fillStyle = "#111"; // fill full bg
  }else{
    ctx.fillStyle = "#000"; // fill full bg
  }
  
  ctx.fillRect(0,0,canvas.width,canvas.height);

  objectArea.render(ctx);
  editorArea.render(ctx);
  
  topToolbarArea.render(ctx);
  rightToolbarArea.render(ctx);

  timelineArea.render(ctx);

  baseButton.render(ctx);
  if(currentGameState ===  GameStates.OPEN_GAME){
    if(gameButton)gameButton.render(ctx);
  }

  renderEntities(ctx);
}

let removeAfterResize = false;
function clipGraphicStatesToViewport() {
  for (const g of graphicStates) {
    for (const a of g.animStates) {
      a.activeCells = a.activeCells.filter(k => {
        const [x,y] = k.split(',').map(Number);
        return x >= 0 && x < config.cols && y >= 0 && y < config.rows;
      });
    }
  }
}

function buildUI() {
  if (config.cols < 10) config.cols = 10;
  if (config.rows < 7) config.rows = 7;

  if(currentAppState == AppStates.FIRST_PLAY  ){
    if(config.cols == 10){
      sCols.status = 4;
    }else if(completeAreaTutorial  && !tutorialOffsetLock){
      sCols.status = 1;
    }

    if(config.rows == 7){
      sRows.status = 4;
    }else if(completeAreaTutorial && !tutorialOffsetLock){
      sRows.status = 1;
    }

  }

  if(removeAfterResize) clipGraphicStatesToViewport();
  testDrawingUser();
  sizeCanvas();
  rebuildLayout(); 
  renderAll();
}


function toggle(pos) {
  if (pos.x < 0 || pos.x >= config.cols || pos.y < 0 || pos.y >= config.rows) return;
  const key = `${pos.x},${pos.y}`, cells = graphicStates[curGfx].animStates[curAnim].activeCells, idx = cells.indexOf(key);
  if (drawMode && idx === -1) cells.push(key); else if (!drawMode && idx !== -1) cells.splice(idx, 1);
  renderAll();
}


function shiftPixels(dx, dy) {
  if(isPlaying && player){
    movePlayer(dx,dy);
    return
  }

  if(isFrameGame && player){
    movePlayer(dx,dy);
    return
  }

  const gfx = graphicStates[curGfx];
  const state = gfx.animStates[curAnim];
  if (!state) return;
  if(lockinitAreaTut){
    tutorialOffset = true;
    checkTutorial();
  }
  state.activeCells = state.activeCells.map(key => {
    const [x, y] = key.split(',').map(Number);
    let newX = (x + dx + config.cols) % config.cols;
    let newY = (y + dy + config.rows) % config.rows;
    return `${newX},${newY}`;
  });
  renderAll();
}


function resizeGrid({ dc = 0, dr = 0 }) { // dc (delta cols), dr (delta rows)
  tutorialResize = true;
  checkTutorial();

  if (dc !== 0) config.cols += dc;
  if (dr !== 0) config.rows += dr;

  buildUI();
}


function addAnim() {
  if (graphicStates[curGfx].animStates.length >= config.cols-2) return;
  const curState = graphicStates[curGfx].animStates[curAnim];
  let newCells = [...curState.activeCells];
  if(!completeAreaTutorial){
    if (newCells.length > 0) newCells.pop(); 
  }
  
  graphicStates[curGfx].animStates.push({ activeCells: newCells, delay: curState.delay || 80 });
  curAnim = graphicStates[curGfx].animStates.length - 1;
  fIdx = curAnim;
  buildUI();
}

function popAnim() {
  if (graphicStates[curGfx].animStates.length > 1) {
    graphicStates[curGfx].animStates.pop();
    curAnim = Math.min(curAnim, graphicStates[curGfx].animStates.length - 1);
    fIdx = curAnim; buildUI();
  }
}

function addGfx() {
  if (graphicStates.length >=  config.rows - 1) return;
  tutorialAFrObj = true;
  checkTutorial();
  graphicStates.push({ offsetX: 0, offsetY: 0, animStates: [{ activeCells: [], delay: 80 }] });
  curGfx = graphicStates.length - 1; curAnim = 0; fIdx = 0; buildUI();
}

let playerInsideEditor =false;
let goalTriedEnterEditor = false;

function isCellBlocked(cellX, cellY, caller) {
  pb = POSITION_BASED;

  const groups = [ topToolbarArea, rightToolbarArea, objectArea ];
  for (const g of groups) {
    if (!g) continue;
    // support both wrappers (objectArea.group.items) and ButtonGroup (items)
    const items = (g.group && g.group.items) ? g.group.items
                : (g.items ? g.items
                : null);
    if (!items) continue;

    for (const b of items) {
      if (b.collision && typeof b.occupiesCell === 'function' && b.occupiesCell(cellX, cellY)) return true;
    }
  }

  // 2) base button
  if (baseButton && baseButton.collision && typeof baseButton.occupiesCell === 'function' && baseButton.occupiesCell(cellX, cellY)) return true;
  if (gameButton && gameButton.collision && typeof gameButton.occupiesCell === 'function' && gameButton.occupiesCell(cellX, cellY)) return true;

  // 3) timeline area (special line that blocks player)
  if (timelineArea && typeof timelineArea.occupiesCell === 'function' && timelineArea.occupiesCell(cellX, cellY)) return true;

  if (editorArea) {
    const localX = (cellX-1) - editorArea.cx;
    const localY = (cellY-1) - editorArea.cy;

    if (localX >= 0 && localX < config.cols && localY >= 0 && localY < config.rows) {
      playerInsideEditor = true;
      goalTriedEnterEditor = true;

      const gfx = graphicStates[curGfx];
      if (gfx && gfx.animStates[curAnim]) {
        const active = gfx.animStates[curAnim].activeCells;
        if (active.includes(`${localX},${localY}`)) return true;
      }
    }else{
      playerInsideEditor = false;
      goalTriedEnterEditor = false;
    }
  }

  return false;
}


function movePlayer(dx, dy) {
  if (!player) return;

  const targetX = player.x + dx;
  const targetY = player.y + dy;
  

  pb = POSITION_BASED;

  // глобальные границы: размер canvas в ячейках
  const totalCols = Math.floor(canvas.width / config.size)+pb;
  const totalRows = Math.floor(canvas.height / config.size) +pb;

  if (targetX < pb || targetX >= totalCols || targetY < pb || targetY >= totalRows) {
    return; // не позволяем выйти за пределы холста
  }

  if (isCellBlocked(targetX, targetY, "player")) {
    return; // блокировка 
  }

  if(goal){
    const goalTargetX = goal.x - dx;
    const goalTargetY = goal.y - dy;  

    targetOutCanvasBoundary = (goalTargetX < pb || goalTargetX >= totalCols || goalTargetY < pb || goalTargetY >= totalRows);

    if (!playerInsideEditor) {
      if (!isCellBlocked(goalTargetX, goalTargetY, "goal")) {
        if(!goalTriedEnterEditor && !targetOutCanvasBoundary){
          goal.x = goalTargetX;
          goal.y = goalTargetY;
        }
      }
    }
  }

  // всё ок — перемещаем игрока
  player.x = targetX;
  player.y = targetY;

  if (isFrameGame) {
      const anims = graphicStates[curGfx].animStates;
      const max = anims.length;

      // dx отвечает за горизонтальное движение
      if (dx > 0) {
          fIdx++;
      } else if (dx < 0) {
          fIdx--;
      }

      // Циклическая прокрутка (wrap)
      if (fIdx >= max) fIdx = 0;
      if (fIdx < 0)   fIdx = max - 1;

      curAnim = fIdx; // активный кадр = индекс кадра

      if (editorArea) {

        const localPX = (player.x-1) - editorArea.cx;
        const localPY = (player.y-1) - editorArea.cy;

        if (localPX >= 0 && localPX < config.cols && localPY >= 0 && localPY < config.rows) {
          const activeCells = anims[fIdx].activeCells;
          if (activeCells.includes(`${localPX},${localPY}`)) {
            GameOver();
          }
        }
      }

      // ОБЯЗАТЕЛЬНО, иначе не увидишь смену
      renderAll();
  }


  if (goal && player.x === goal.x && player.y === goal.y) {
    isPlaying = false;
    //alert("Цель достигнута!");
    if(currentGameState ===  GameStates.GOAL_SPAWN){
      currentGameState = GameStates.OPEN_GAME;
      gameButton = new UIButton("⏯\u{FE0E}", gameButtonAction, { S:4 })
    }

    if(currentGameState === GameStates.OPEN_GAME && isFrameGame){
      saveButton.status = 1;
      console.log("COMPLETE FRAME GAME");
    }

    if(currentGameState ===  GameStates.OPEN_GAME){
      isFrameGame = false;
      baseButton.status = 1;
    }

    GameOver(1);
    return;
  }

  renderAll();
}

function spawnGameEntities() {
  isGameOver = false;

  if (!editorArea) { // 1 based
    var shiftAreaX = 1;
    var shiftAreaY = 1;
  } else {
    var shiftAreaX = editorArea.cx; // 1 based - будет на одну ячейку меньше
    var shiftAreaY = editorArea.cy+1; 
  }

  if(currentGameState === GameStates.FIRST_SPAWN){
        // первое появление игрока
        newy = Math.floor(Math.random() * config.rows);
        //player = { x: shiftAreaX,                   y: shiftAreaY + newy };
        player = { x: 10,                   y: 1 };
    }else if(currentGameState === GameStates.GOAL_SPAWN) {
        // появляется цель + игрок
        newy = Math.floor(Math.random() * config.rows);
        player = { x: shiftAreaX,                   y: shiftAreaY + newy };
        goal   = { x: shiftAreaX + config.cols + 1, y: (shiftAreaY-1) + config.rows - newy };
    }else if(currentGameState === GameStates.OPEN_GAME){
        // полная логика случайного спауна (требуется дописать)
        newy = Math.floor(Math.random() * config.rows);
        player = { x: shiftAreaX,                   y: shiftAreaY + newy };
        goal   = { x: shiftAreaX + config.cols + 1, y: (shiftAreaY-1) + config.rows - newy }; 
    }

}

function deSpawnGameEntities() {
  isGameOver = true;
  player = null;
  goal = null;
}

function clampAnimIndex() {
    const frames = graphicStates[curGfx].animStates.length;
    if (curAnim >= frames) curAnim = frames - 1;
    if (fIdx >= frames) fIdx = frames - 1;
    if (curAnim < 0) curAnim = 0;
    if (fIdx < 0) fIdx = 0;
}

function GameOver(status) {
  console.log("GameOver");
  //alert("Игрок раздавлен блоком!");

  isPlaying = false;

  deSpawnGameEntities();

  baseButton.setText("\u25B6\uFE0E"); // ▶︎

  if(currentGameState === GameStates.FIRST_SPAWN){
    currentGameState = GameStates.GOAL_SPAWN;
    aCols.status = 1;
    aRows.status = 1;
    sCols.status = 1;
    sRows.status = 1;
    tutorialOffsetLock = false;   
    console.log("Добавляем активную цель");
  }

  if(currentGameState === GameStates.OPEN_GAME){
    isFrameGame = false;
    baseButton.status = 1;
  }

  buildUI();

  // if not Work Loop Sequence Try this flags
  //curGfx = 0, curAnim = 0, isInitialized = true;
  //clampAnimIndex();
  
  //lastT = 0; fIdx = 0;
  //curAnim = 0;
}




function baseButtonAction() {
  // Три состояния RESET\PLAY\PAUSE

  if (currentAppState === AppStates.INTRO){
    currentAppState = AppStates.FIRST_RESET;
    resetAction();
    return
  }

  if (currentAppState === AppStates.FIRST_DRAW){ 
    isPlaying = true;
    currentAppState = AppStates.FIRST_PLAY;
    baseButton.setText("\u23F8\uFE0E"); //⏸︎ PAUSE
    
    console.log("FIRST_PLAY");
    return
  }

  if (currentAppState === AppStates.FIRST_PLAY){ 
    
    if(!completeAreaTutorial){
      mLeft.status = 1;
      mUp.status = 1;
      mDown.status = 1; 
      mRight.status = 1;
      timelineArea.plusBtn.status = 4;
    }


    isPlaying = !isPlaying; 

    if(isPlaying){ 
      lastT = 0;

      // Зная, что игрок уже воспроизводил и ставил на паузу > открываем игровую логику
      if(currentGameState != GameStates.OPEN_GAME){spawnGameEntities();}
      baseButton.setText("\u23F8\uFE0E"); //⏸︎ PAUSE

    }else{

      checkTutorial(); 

      if(currentGameState != GameStates.OPEN_GAME){deSpawnGameEntities();}  
      baseButton.setText("\u25B6\uFE0E"); // ▶︎ 
    }

    console.log("PLAYING STATUS", isPlaying);
    
    buildUI();
    return
  }

  // Обычная логика reset кнопки (лучше потом обернуть в условие)
  resetAction();
}

function gameButtonAction() {

    isFrameGame = !isFrameGame;
    
    if(isFrameGame){ 
      isPlaying = false; 
      baseButton.status = 0;
      baseButton.setText("\u25B6\uFE0E"); // ▶︎
      spawnGameEntities();
    }else{ 
      deSpawnGameEntities();
      baseButton.status = 1;
    }
    
    buildUI();
}


function resetAction() {
  config = JSON.parse(JSON.stringify(DEFAULTS_SETUP.config));
  graphicStates = JSON.parse(JSON.stringify(DEFAULTS_SETUP.states));
  curGfx = 0; curAnim = 0; fIdx = 0; isPlaying = false; isInitialized = false;

  if(!completeAreaTutorial){
    loadButton.status = 4;
    saveButton.status = 4;
  }

  buildUI();
}

let unlockPlus = false;
function testDrawingUser(){    
    if (currentAppState != AppStates.FIRST_RESET) return;

    const currentGfx = graphicStates[curGfx];
    const hasPixels = currentGfx.animStates.some(a => a.activeCells.length > 2);

    if(hasPixels && !unlockPlus){
      timelineArea.plusBtn.status = 1;
      unlockPlus = true;
      console.log("UNLOCK TIMELINE PLUS", timelineArea.plusBtn.status);
    }

    const hasMultipleFrames = currentGfx.animStates.length > 1;

    // Кнопка PLAY появляется ТОЛЬКО если кадров больше двух и больше двух активных ячеек
    if (!isInitialized && hasPixels && hasMultipleFrames) {
        baseButton.setText("\u25B6\uFE0E"); // ▶︎
        currentAppState = AppStates.FIRST_DRAW;
        console.log("FIRST_DRAW");
        return;
    }
}


// Listeners and Controls

canvas.addEventListener('mousedown', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const px = Math.floor(e.clientX - rect.left);
  const py = Math.floor(e.clientY - rect.top);
  mouseDown = true;

  if(baseButton.contains(px,py) && baseButton.onClick && baseButton.status !== 0  && baseButton.status !== 4) {
    baseButton.onClick();
  }

  if(currentAppState == AppStates.INTRO){
    let btn = topToolbarArea.find(px,py);
    if (btn && btn.onClick && btn.status !== 0 && btn.status !== 4) {
      btn.onClick();
      rebuildLayout(); renderAll();
      return;
    }else{
      return;
    }
  }

  // check UI buttons first (priority)
  // toolbar
  let btn = topToolbarArea.find(px,py) || objectArea.find(px,py) || timelineArea.find(px,py) || rightToolbarArea.find(px,py);
  if (btn && btn.onClick && btn.status !== 0 && btn.status !== 4) {
    btn.onClick();
    rebuildLayout(); renderAll();
    return;
  }

  const L = canvas._layout;
  const rightX = L.leftW + L.editorW;
  if (px >= rightX && px < rightX + L.rightW) {
    const idx = Math.floor((py - L.topH) / config.size);
    if (idx >= 0 && idx <= 5) {
      // map
      switch(idx){
        case 0: config.cols++; break;
        case 1: config.cols--; break;
        case 2: config.size += 2; break;
        case 3: config.size -= 2; break;
        case 4: config.rows--; break;
        case 5: config.rows++; break;
      }
      buildUI();
      return;
    }
  }



  if(gameButton){
    if(gameButton.contains(px,py) && gameButton.onClick && gameButton.status !== 0 && baseButton.status !== 4) {
      gameButton.onClick();
    }
  }


  // if click inside editor area -> start drawing
  if (editorArea.contains(px,py)) {
    isDrawing = true; isInitialized = false; isPlaying = false;
    const pos = editorArea.getPosFromCanvas(px,py);
    drawMode = !graphicStates[curGfx].animStates[curAnim].activeCells.includes(`${pos.x},${pos.y}`);
    toggle(pos);
  }
});

window.addEventListener('mousemove', (e)=>{
  if (!mouseDown) return;
  const rect = canvas.getBoundingClientRect();
  const px = Math.floor(e.clientX - rect.left);
  const py = Math.floor(e.clientY - rect.top);
  if (isDrawing && editorArea.contains(px,py)) {
    const pos = editorArea.getPosFromCanvas(px,py);
    toggle(pos);
  }
});

window.addEventListener('mouseup', (e)=>{
  mouseDown = false;
  if (isDrawing) { isDrawing = false; buildUI(); }
});

/* Keyboard handling — reuse previous mapping */
window.addEventListener('keydown', (e)=>{
  if (isDrawing) return;
  if (isPlaying){
    switch(e.key) {
      case 'ArrowLeft':  movePlayer(-1, 0); break;
      case 'ArrowRight': movePlayer(1, 0);  break;
      case 'ArrowUp':    movePlayer(0, -1); break;
      case 'ArrowDown':  movePlayer(0, 1);  break;
    }
  } else {
    switch(e.key) {
      case 'ArrowLeft':  shiftPixels(-1, 0); break;
      case 'ArrowRight': shiftPixels(1, 0);  break;
      case 'ArrowUp':    shiftPixels(0, -1); break;
      case 'ArrowDown':  shiftPixels(0, 1);  break;
    }
  }
});


// LOAD / SAVE USER DATA

function exportJSON() {
  const data = JSON.stringify({ config, graphicStates });
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'project.json'; a.click();
}

fileInput.addEventListener('change', (ev)=>{
  const f = ev.target.files && ev.target.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = (e)=>{
    try {
      const data = JSON.parse(e.target.result);
      config = data.config; graphicStates = data.graphicStates;
      isInitialized = false; isPlaying = false; curGfx = 0; curAnim = 0; fIdx = 0;
      buildUI();
    } catch(err){ alert("Ошибка при чтении JSON файла"); }
  };
  reader.readAsText(f);
});

function unlockAllButtons(){
  mLeft.status = 1;
  mUp.status = 1;
  mDown.status = 1; 
  mRight.status = 1;

  aCols.status = 1;
  sCols.status = 1;
  sRows.status = 1; 
  aRows.status = 1;

  if(!gameButton){
    gameButton = new UIButton("⏯\u{FE0E}", gameButtonAction, { S:4 })
    gameButton.status = 1;
  }

 currentAppState = AppStates.FIRST_PLAY;
 currentGameState = GameStates.OPEN_GAME;
}

// ОСНОВНОЙ ЦИКЛ
function startLoop() {
  if (_rafId === null) _rafId = requestAnimationFrame(loop);
}
function stopLoop() {
  if (_rafId !== null) { cancelAnimationFrame(_rafId); _rafId = null; }
}  

document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // при сворачивании — можно паузить анимацию или хотя бы уменьшить частоту
    _loopPausedByVisibility = true;
    // если хотите полностью стоп: stopLoop();
  } else {
    _loopPausedByVisibility = false;
    startLoop();
  }
});

function loop(t) {

  if (isPlaying) {
    //console.log("PLAY-BLOCK ENTERED");

    const gfx = graphicStates[curGfx];
    if (gfx) {
      const anims = gfx.animStates;
      const currentDelay = anims[fIdx] ? anims[fIdx].delay : 80;

      //console.log("currentDelay:", currentDelay);

      if(!isFrameGame){

        if (t - lastT > currentDelay) {
          //console.log("FRAME ADVANCE TRIGGERED");
          lastT = t;
          curAnim = fIdx;

          // если сменился текущий графический объект или изменилось кол-во кадров — обновим timeline
          // (анимы уже доступны как `anims`)
          if (timelineArea) {
            const frameCount = anims.length;
            if (timelineArea._lastGfxIndex !== curGfx || timelineArea._lastFrameCount !== frameCount) {
              timelineArea.refresh();
              timelineArea._lastGfxIndex = curGfx;
              timelineArea._lastFrameCount = frameCount;
            }
          }

          // collision editor cells with player
          if (player && editorArea) {

            const localPX = (player.x-1) - editorArea.cx;
            const localPY = (player.y-1) - editorArea.cy;

            if (localPX >= 0 && localPX < config.cols && localPY >= 0 && localPY < config.rows) {
              const activeCells = anims[fIdx].activeCells;
              if (activeCells.includes(`${localPX},${localPY}`)) {
                GameOver();
                //return;
              }
            }
          }

          renderAll();

          fIdx++;
          if (fIdx >= anims.length) {
            fIdx = 0;
            curGfx = (curGfx + 1) % graphicStates.length;
            curAnim = 0;
          }
        }
      }else{

        // !! логика смещения кадра от движения персонажа в режиме isGameFrame
      }

    }
  }
  _rafId = requestAnimationFrame(loop);
  //requestAnimationFrame(loop);
}

function buildUIOnceAndStart() {
  buildUI();
  requestAnimationFrame(loop);
}

//   Initialize

buildUIOnceAndStart();
window._debug = { config, graphicStates, buildUI, renderAll };

</script>
</body>
</html>