<!DOCTYPE html>
<html lang="ru">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="description" content="Присутствуют негативы, почти целый триптих и многое другое..." />

<meta property="og:title" content="вский.space">
<meta property="og:type" content="website">
<meta property="og:url" content="https://vsky.space/">
<meta property="og:description" content="Присутствуют негативы, почти целый триптих и многое другое...">
<meta property="og:image" content="https://vsky.space/content/vsky.jpg">
<meta property="og:image:secure_url" content="https://vsky.space/content/vsky.jpg">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="вский.space">
<meta name="twitter:description" content="Присутствуют негативы, почти целый триптих и многое другое...">
<meta name="twitter:image" content="https://vsky.space/content/vsky.jpg">
<meta name="twitter:site" content="@AleksandrovskyV">

<meta vdebugmode="ios">

<script>
</script>


<title>вский.space</title>

<link rel="canonical" href="https://vsky.space/">

<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/content/favicon-16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/content/favicon-32.png">
<link rel="apple-touch-icon" sizes="180x180" href="/content/apple-touch-icon.png">



<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html, body {
    height: 100%;
    background: #000;
    margin: 0;
    padding: 0;
  }

  /* Классы для Desktop */

  .overlay{
    position:fixed;

    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:1000;
  }

  .buttonblock{
    display:flex;
    flex-wrap:wrap;           
    gap:16px;
    width: min(90vw, 700px);
    height: min(90vh, 680px);
    align-content:center;
    justify-content: space-between; 
    padding:20px;
    background:transparent;
  }


  .buttonblock button,
  .buttonblockMobile button{
    flex: 0 0 auto;  
    display:inline-flex;
    align-items:center;
    justify-content:center;
    padding:12px 12px;
    font-size:1.25rem;
    color: gray;
    background: rgba(0,0,0,0.0);
    border: 0;
    cursor:pointer;
    transition: opacity .6s ease, transform .45s cubic-bezier(.2,.9,.2,1);
    will-change: opacity, transform;
    z-index: 99;
  }

  .buttonblock button:not([data-state="close"]):hover {
    opacity: .5;
  }

  .buttonblock button[data-state="close"] {
    cursor: grab;
    color: rgba(70,70,70,1.0);
  }

  /* убрать в мобильной*/
  .buttonblock button[data-state="close"]:active {
    cursor: grabbing; /* сжатая ладонь */
    transform: scale(0.99); 
    color: rgba(50,50,50,1.0); 
  }


  /* Классы для мобильной */

  .overlayMobile{
    position: fixed;

    top: env(safe-area-inset-top, 0);
    left: env(safe-area-inset-left, 0);
    right: env(safe-area-inset-right, 0);
    bottom: env(safe-area-inset-bottom, 0);
    
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  }

  .buttonblockMobile{
    padding: env(safe-area-inset-top, 12px)
             env(safe-area-inset-right, 12px)
             env(safe-area-inset-bottom, 12px)
             env(safe-area-inset-left, 12px);

    display:flex;
    flex-wrap:wrap;           /* перенос строк */
    gap:16px;
    justify-content: space-between; /* ключ! */
    background:transparent;
  }

  .buttonblockMobile button:not([data-state="close"]):hover {
    opacity: .5;
  }

  .buttonblockMobile button[data-state="close"] {
    color: rgba(70,70,70,1.0);
  }



  .hidden-btn{
    opacity: 0 !important;
    pointer-events: none !important;
  }

  /* после завершения анимации мы дополнительно ставим visibility:hidden (JS) —
     это защищает от :hover и от фокусировки через клавиатуру */
  .background{
    position:absolute;inset:0;background:#000;z-index:0;transition:opacity 1.2s ease;
  }

  /* маленькие устройства — уменьшаем отступ и шрифт */
  @media (max-width:420px){
    .buttonblock,
    .buttonblockMobile {
      gap:10px;
      padding:12px;
    }

    .buttonblock button,
    .buttonblockMobile button{
      padding:10px 14px;
      font-size:1rem;
    }
  }
</style>

</head>
<body>


<div class="overlay" id="mOverlay">
  <div class="buttonblock" id="mButtonsContainer"> 
    <!-- mobile special -->
    <button data-href="/chat"     data-state="open"  data-mobile="true" >chat___</button>
    <button data-href="/день"     data-state="open"  data-mobile="true" >день</button>
    <button data-href="/триптих"  data-state="open"  data-mobile="true" >триптих</button>

    <!-- combine between web and mobile  -->
    <button data-href="/негативы" data-state="open"  data-mobile="false" >негативы</button>
    <button data-href="/exegesis" data-state="open"  data-mobile="false" >.exe</button>
    <button data-href="/wolume"   data-state="open"  data-mobile="false" >~</button>

    <button data-href="/identity" data-state="close" data-mobile="false" >identity</button>
  

    <button data-href="/renders"  data-state="close" data-mobile="false" >_enders</button>
    <button data-href="/снимки"   data-state="close" data-mobile="false" >снимки</button>
    <button data-href="/графика"  data-state="close" data-mobile="false" >графика</button>
  
    <button data-href="/bread"    data-state="close" data-mobile="false" >bread</button>
    <button data-href="/haloguys" data-state="close" data-mobile="false" >[ haloguys ]</button>
    <button data-href="/покпокки" data-state="close" data-mobile="false" >покпокки</button>
  
    <button data-href="/работа"   data-state="close" data-mobile="false" >работа</button>
    <button data-href="/process"  data-state="close" data-mobile="false" >_cess</button>

    <button data-href="/const"    data-state="close" data-mobile="false" >/</button>
    <button data-href="/space"    data-state="close" data-mobile="false" >—</button>
  
    <button data-href="/about"    data-state="close" data-mobile="false" >[ &hearts; ]</button>
  </div>
  <div class="background" id="mBackground"></div>
</div>

<script>

  const debugMode = false

  const ua = navigator.userAgent.toLowerCase();
  const isMobile = /iphone|ipad|android/.test(ua);

  const overlay = document.getElementById('mOverlay');
  const buttonContainer = document.getElementById('mButtonsContainer');

  const buttons = Array.from(buttonContainer.querySelectorAll('button'));
  const heart = buttons.find(b => b.dataset.href === "/about");
  
  if (!isMobile) {
    heart.textContent = '[ ❤ ]';
  } else {
    overlay.classList.replace('overlay', 'overlayMobile');
    buttonContainer.classList.replace('buttonblock', 'buttonblockMobile');
  }
  
  // ВОССТАНОВЛЕНИЕ ПОСЛЕ ВОЗВРАТА НАЗАД
  window.addEventListener("pageshow", (event) => {
    if (event.persisted) {
      // только восстанавливаем видимость скрытых кнопок
      buttons.forEach(btn => {
        if(btn.classList.contains('hidden-btn')){
          btn.classList.remove('hidden-btn');
          btn.style.visibility = 'visible';
        }
      });
      buttonContainer.style.pointerEvents = "";
    }
  });


  /* ========== Автоматическая подстройка размера шрифта в зависимости от кол-ва кнопок ==========
     простая эвристика: чем больше кнопок — тем меньше шрифт (можно настроить под себя).
  */
  (function adjustFontByCount(){
    const n = buttons.length;

    //web - 4.6 
    const base = isMobile ? 4.4 : 4.6;
    const sizeRem = Math.max(0.9, base - (n - 3) * 0.12);
    buttons.forEach(b => b.style.fontSize = sizeRem + 'rem');
  })();


  function removeOverflowingCloseButtons() {
    // метод удаления кнопок в мобильной версии
    const container = buttonContainer;
    const maxHeight = overlay.clientHeight;

    // Пока контент не помещается
    while (container.scrollHeight > maxHeight) {
      // Берём все кнопки close, кроме исключений

      const closeButtons = Array.from(container.querySelectorAll('button[data-state="close"]'))
        .filter(btn => btn.dataset.href !== '/space' && btn.dataset.href !== '/about');

      if (closeButtons.length === 0) break; // Больше нечего удалять

      // Удаляем последнюю подходящую кнопку
      const btnToRemove = closeButtons.pop();
      container.removeChild(btnToRemove);
    }
  }

  function hideAllButtons() {
    return new Promise(resolve => {
      let finished = 0;
      const total = buttons.length;

      function onTransitionEnd(e) {
        if (e.propertyName !== 'opacity') return;
        finished++;
        if (finished >= total) {
          cleanup();
          buttons.forEach(btn => btn.style.visibility = 'hidden');
          resolve();
        }
      }

      function cleanup(){
        buttons.forEach(btn => btn.removeEventListener('transitionend', onTransitionEnd));
      }

      // привязываем слушатель И запускаем анимацию скрытия
      buttons.forEach(btn => btn.addEventListener('transitionend', onTransitionEnd));
      // небольшая задержка, чтобы гарантировано применился класс и началась анимация
      requestAnimationFrame(() => {
        buttons.forEach(btn => btn.classList.add('hidden-btn'));
      });

      // safety fallback — если transitionend не сработает, через 1.2s всё равно продолжим
      setTimeout(() => {
        if (finished < total) {
          cleanup();
          buttons.forEach(btn => btn.style.visibility = 'hidden');
          resolve();
        }
      }, 1400);
    });
  }

  function shuffleButtonsWithRules() {
    const container = buttonContainer;

    // слишком мало кнопок для перемешивания
    if (buttons.length <= 3) return; 

    // находим фиксированные
    const pre_a = buttons.find(b => b.dataset.href === "/space");
    const last = buttons.find(b => b.dataset.href === "/about");

    // кнопки, которые нельзя ставить последними перед фиксированными
    const excl = buttons.filter(b => b.dataset.href === "/wolume" || b.dataset.href === "/const");

    // остальные кнопки
    const rest = buttons.filter(b => ![last, pre_a].includes(b));

    // функция перемешивания Fisher–Yates
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    // перемешиваем, пока последний элемент локального массива не будет в excl
    let valid = false;
    while (!valid) {
      shuffle(rest);
      const lastRest = rest[rest.length - 1];
      valid = !excl.includes(lastRest);
    }

    // очищаем контейнер
    container.innerHTML = "";

    // вставляем перемешанные кнопки
    rest.forEach(btn => container.appendChild(btn));

    // вставляем фиксированные в конец 
    container.appendChild(pre_a);
    container.appendChild(last); 
  }

  // Вызов при загрузке
  shuffleButtonsWithRules();

  if (isMobile) {
    removeOverflowingCloseButtons();
  }

  buttons.forEach(btn => {
    btn.addEventListener('click', async (ev) => {
      
      if (btn.dataset.state === 'close') {
        ev.preventDefault();
        return false;
      }

      // Для остальных кнопок
      let target = btn.dataset.href || '#';

      ev.preventDefault();
      buttonContainer.style.pointerEvents = 'none';
      await hideAllButtons();

      if (window.location.protocol === "file:") {
        // локальная отладка
        if (target.startsWith("/")) target = target.slice(1);
        target = target + ".html";
      } else {
        // сервер
        if (target.endsWith(".html")) {
          target = "/" + target.replace(".html", "");
        }
      }

      if (isMobile && btn.dataset.mobile === 'true') {
        target = "/ios" + target;
      }

      window.location.href = target;

    });
  });


</script>

</body>
</html>
