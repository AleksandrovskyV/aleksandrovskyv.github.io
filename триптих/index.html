<!DOCTYPE html>
<html lang="ru">
<head>

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<title>триптих</title>

<link rel="preload" as="image" href="/content/trip/lock.png">
<link rel="preload" as="image" href="/content/trip/open.png">

<script>
  (function () {
    const ua = navigator.userAgent.toLowerCase();
    const isMobile = /iphone|ipad|android/.test(ua);

    if (isMobile) {
      // Ранний мгновенный редирект до загрузки Main
      location.replace("/ios/триптих");
    }
  })();
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.12.2/lottie.min.js"></script>

<style>
body {
  margin: 0;
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  background: #000;
  overflow: hidden;
}

body:not(.ready) .container {
  visibility: hidden;
}

.container {
  display: flex;
  gap: 40px;
  max-width: 1600px;
  padding: 20px;
  box-sizing: border-box;
  width: 100%;
}

.block {
  position: relative;
  overflow: hidden;
  flex: 1 1 0;
  aspect-ratio: 9 / 16;
  background-size: cover;
  background-position: center;
}

.block img,
.block video {
  width: 100.1%;
  height: 100.1%;
  object-fit: cover;
  pointer-events: none;
  user-select:none;
  filter: drop-shadow(0 10px 35px rgba(0, 0, 0, 0.6))
          drop-shadow(0 5px 10px rgba(0, 0, 0, 0.35));
}

/* ===== fake-video ===== */
.video-stub {
  width: 100.1%;
  height: 100.1%;
  object-fit: cover;
  pointer-events: none;
}


/* ===== curtain ===== */
.curtain {
  position: absolute;
  inset: 0;
  z-index: 2;
  touch-action: none;
  transform: translateX(0);
  transition: transform 2.00s ;
  
  will-change: transform;
}

.curtain,
.curtain * {
  user-select: none;
  -webkit-user-select: none;
}

/* ===== overlay ===== */
.curtain .overlay {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,.5);
  pointer-events: none;
  transition: opacity 1s;
  z-index: 10;
}

.curtain .overlay.hidden {
  opacity: 0;
}

/* ===== posters ===== */
.lock-block,
.open-block {
  position: absolute;
  inset: 0;
  background-size: cover;
  background-position: center;
  pointer-events: none;
  transition: opacity 1.00s;
  width: 100.2%;
  height: 100.2%;
}

.lock-block {
  background-image: url(/content/trip/lock.png);
  z-index: 3;
}

.lock-block.hidden { opacity: 0; }

.open-block {
  background-image: url(/content/trip/open.png);
  background-size: cover;
  background-position: center;
  z-index: 5;
  opacity: 0;
}

.video-block.unlocked.paused .open-block {
  opacity: 1;
}


/* конструкция за шторкой */
.constr-lottie {
  position: absolute;
  top: 0;
  bottom: 0;

  left: 50%;
  transform: translateX(-50%);

  height: 100%;
  aspect-ratio: 846 / 1280;

  z-index: -1;
  pointer-events: none;
}

/* ===== cursors ===== */
/* pointer как fallback, если JS не сработает */
.video-block .curtain {
  cursor: pointer;
}

/* ===== кнопка назад ===== */
#toMainBtn{
  position:fixed;
  display: none;
  top:12px; left:24px;
  padding:24px;
  font-size:2.0rem;
  color: gray;
  background: rgba(0,0,0,0.45);
  border: 0;
  cursor:pointer;
  z-index: 999;
  transition: opacity .6s ease, transform .45s cubic-bezier(.2,.9,.2,1);
}
#toMainBtn:hover{opacity:0.5;}

</style>


</head>
<body>

<div class="container">

  <!-- ===== VIDEO BLOCK 1 ===== -->
  <!-- заглушка вместо video -->
  
  <div class="block video-block" data-video="false">
    <img src="/content/trip/stat_alt.png" draggable="false">

    <div class="curtain">
      <div class="constr-lottie"></div>
      <img class="video-stub" src="/content/trip/lock.png" width="720" height="1280" alt="poster" />
      <div class="lock-block"></div>
      <div class="open-block"></div>
      <div class="overlay"></div>
    </div>
  </div>

  <!-- ===== VIDEO BLOCK 2 ===== -->

  <div class="block video-block">
    <img src="/content/trip/2_bird_descr.png" draggable="false">

    <div class="curtain">
      <div class="constr-lottie"></div>
      <video src="/content/video/Bird_Web.mp4" id="VideoB" loop poster="/content/trip/lock.png" preload="metadata"></video>
      <div class="lock-block"></div>
      <div class="open-block"></div>
      <div class="overlay"></div>
    </div>
  </div>

  <!-- ===== VIDEO BLOCK 3 ===== -->

  <div class="block video-block">
    <img src="/content/trip/3_cat_descr.png" draggable="false">
    <div class="curtain">
    <div class="constr-lottie"></div>
      <video src="/content/video/Cat_Web.mp4" id="VideoC" loop poster="/content/trip/lock.png" preload="metadata"></video>
      <div class="lock-block"></div>
      <div class="open-block"></div>
      <div class="overlay"></div>
    </div>
  </div>

</div>


<button id="toMainBtn" data-href="/"><</button>


<script>
(async function preloadCritical() {
  const urls = [
    "/content/trip/lock.png"
  ];

  await Promise.all(urls.map(src => new Promise(res => {
    const img = new Image();
    img.onload = res;
    img.onerror = res; // На всякий случай — не виснуть
    img.src = src + "?v=" + Date.now(); // предотвращаем CDN-кэш гонку
  })));

  document.body.classList.add("ready");
})();
</script>


<script>

//const VideoBlockA = document.getElementById('VideoA');
const VideoBlockB = document.getElementById('VideoB');
const VideoBlockC = document.getElementById('VideoC');

let LoopCompletedA = false;
let LoopCompletedB = false;
let LoopCompletedC = false;

/*
VideoBlockA.addEventListener("timeupdate", () => {
  console.log(VideoBlockA.currentTime.toFixed(2), "/", VideoBlockA.duration.toFixed(2));
});

VideoBlockB.addEventListener("timeupdate", () => {
  console.log(VideoBlockB.currentTime.toFixed(2), "/", VideoBlockB.duration.toFixed(2));
});

VideoBlockC.addEventListener("timeupdate", () => {
  console.log(VideoBlockC.currentTime.toFixed(2), "/", VideoBlockC.duration.toFixed(2));
});
*/

function createFakeVideo() {
  return {
    play() { return Promise.resolve(); },
    pause() {},
    addEventListener() {},
    removeEventListener() {},
    muted: true,
    currentTime: 0,
    duration: 0
  };
}

function trackFirstLoop(video, onComplete) {
  let lastTime = 0;
  let completed = false;

  video.addEventListener("timeupdate", () => {
    if (completed || !video.duration) return;

    const t = video.currentTime;
    const d = video.duration;

    if (lastTime > d * 0.95 && t < lastTime) {
      completed = true;
      onComplete(); //  ВАЖН
      console.log("Первый цикл завершён:");

    }

    lastTime = t;
  });
}


/* ======================================================
   LOTTIE LOGIC
====================================================== */


const FRAME_MIN = 0;
const FRAME_MAX = 180;
const FRAME_CENTER = 90;

const BASE_BLOCK_WIDTH = 720;
const BASE_DRAG_LIMIT = 833.3;

let DRAG_LIMIT = BASE_DRAG_LIMIT;
let lastX = 0, lastY = 0;

function updateDragLimit(block) {
  const rect = block.getBoundingClientRect();
  DRAG_LIMIT = BASE_DRAG_LIMIT * (rect.width / BASE_BLOCK_WIDTH);
}

function mapDragToFrame(x) {
  // clamp
  const clamped = Math.max(-DRAG_LIMIT, Math.min(DRAG_LIMIT, x));

  if (clamped >= 0) {
    // вправо: 90 → 180
    return FRAME_CENTER +
      (clamped / DRAG_LIMIT) * (FRAME_MAX - FRAME_CENTER);
  } else {
    // влево: 90 → 0
    return FRAME_CENTER +
      (clamped / DRAG_LIMIT) * (FRAME_CENTER - FRAME_MIN);
  }
}


/* ======================================================
   VIDEO BLOCKS
====================================================== */

document.querySelectorAll(".video-block").forEach(block => {
  /* drag с синхронизацией hover */
  let dragging = false, startX = 0, offset = 0;
  let currentX = 0;
  const getX = e => e.touches ? e.touches[0].clientX : e.clientX;

  let returnRAF = null;
  let isReturning = false;
  let curtainEnabled = false;

  let isDragging = false; // локальная переменная для курсора?

  const realVideo = block.querySelector("video");
  const hasVideo = block.dataset.video !== "false";

  const curtain = block.querySelector(".curtain");
  const lock = block.querySelector(".lock-block");
  const overlay = block.querySelector(".curtain .overlay");
  const lottieContainer = block.querySelector('.constr-lottie');




  const video = hasVideo && realVideo
    ? realVideo
    : createFakeVideo();


  if (realVideo) {
    trackFirstLoop(realVideo, () => {
      curtainEnabled = true;
      block.classList.add("curtain-enabled");
      
      // Форсируем обновление курсора
      updateCurtainCursor(block);

    });
  } else {
    // если fake-video (картинка) — можно сразу разрешить
    curtainEnabled = true;
    block.classList.add("curtain-enabled");
  }


  const constrAnim = lottie.loadAnimation({
    container: lottieContainer,
    renderer: 'svg',
    loop: false,
    autoplay: false,
    path: '/content/trip/constr.json'
  });

  // ---------------------- CurtainSoundController ----------------------
  class CurtainSoundController {
    constructor() {
      // аудио-файлы (по одному экземпляру на блок)
      this.gearsIn = new Audio('/content/audio/roll_gears_in.wav');
      this.gearsIn.preload = 'auto';
      this.gearsIn.loop = false;

      this.gearsLoop = new Audio('/content/audio/roll_gears_loop.wav');
      this.gearsLoop.preload = 'auto';
      this.gearsLoop.loop = true;
      this.gearsLoop.volume = 0.8;

      this.curtainOut = new Audio('/content/audio/roll_gears_out.wav');
      this.curtainOut.preload = 'auto';
      this.curtainOut.loop = false;
      this.curtainOut.volume = 1.0;

      this.lastMoveTime = 0;
      this.lastMoveX = 0;

      // thresholds / tuning
      this.START_SPEED_THRESHOLD = 0.6; // px/ms — для _in (намерение)
      this.MOVE_EPSILON = 0.5; // px — для фикса движения (loop)
      this.MOVE_SILENCE_TIMEOUT = 80; // ms — таймер «тишины» для остановки loop
      this.LOOP_FADE_MS = 500; // ms — fade при остановке loop

      // state
      this.gearsInAllowed = true; // разрешение на _in (сбрасывается в finalize)
      this.dragStartedForIn = false; // только для _in (ev)
      this.hasUserMovement = false; // для loop (state)
      this.isLoopPlaying = false;

      // internal timers / raf
      this.moveSilenceTimer = null;
      this.loopFadeRAF = null;
      this.loopFadeStartVol = this.gearsLoop.volume;
      this.scheduledTimeout = null; // для curtainOut
      this.curtainFadeInterval = null; // оставляем для curtainOut fade logic, если нужно
    }

    // отменить любые запланированные запуски return audio
    clearScheduledCurtain() {
      if (this.scheduledTimeout) {
        clearTimeout(this.scheduledTimeout);
        this.scheduledTimeout = null;
      }
    }

    // play curtain out with offset (call from outer schedule)
    playCurtainFrom(offsetSec = 0) {
      this.clearScheduledCurtain();
      try { this.curtainOut.currentTime = offsetSec; } catch (e) {}
      this.curtainOut.play().catch(()=>{});
    }

    // schedule for return (same behaviour как раньше)
    scheduleCurtainForReturn(delaySec, offsetIfEarly = 0) {
      this.clearScheduledCurtain();
      if (delaySec > 0) {
        this.scheduledTimeout = setTimeout(() => this.playCurtainFrom(0), Math.round(delaySec * 1000));
      } else {
        this.playCurtainFrom(offsetIfEarly);
      }
    }

    // fade out loop over ms (cancellation safe)
    fadeOutLoop(durationMs = this.LOOP_FADE_MS) {
      if (!this.isLoopPlaying) return;
      if (this.loopFadeRAF) {
        cancelAnimationFrame(this.loopFadeRAF);
        this.loopFadeRAF = null;
      }

      const startVol = this.gearsLoop.volume || this.loopFadeStartVol;
      const start = performance.now();

      const step = (t) => {
        const p = Math.min(1, (t - start) / durationMs);
        this.gearsLoop.volume = startVol * (1 - p);
        if (p < 1) {
          this.loopFadeRAF = requestAnimationFrame(step);
        } else {
          try {
            this.gearsLoop.pause();
            this.gearsLoop.currentTime = 0;
          } catch (e) {}
          this.gearsLoop.volume = startVol;
          this.isLoopPlaying = false;
          this.loopFadeRAF = null;
        }
      };
      this.loopFadeRAF = requestAnimationFrame(step);
    }

    // immediate stop (no fade) — use rarely
    stopLoopNow() {
      if (this.loopFadeRAF) { cancelAnimationFrame(this.loopFadeRAF); this.loopFadeRAF=null; }
      try { this.gearsLoop.pause(); this.gearsLoop.currentTime = 0; } catch(e){}
      this.isLoopPlaying = false;
      if (this.moveSilenceTimer) { clearTimeout(this.moveSilenceTimer); this.moveSilenceTimer = null; }
    }

    // stop loop politely (fade + clear timer)
    stopLoopPolite() {
      if (this.moveSilenceTimer) { clearTimeout(this.moveSilenceTimer); this.moveSilenceTimer = null; }
      this.fadeOutLoop(this.LOOP_FADE_MS);
    }

    // reset states (on pointerdown)
    onStart() {
      // user begins an interaction: reset movement/in flags; stop loop if it played
      this.hasUserMovement = false;
      this.dragStartedForIn = false;
      this.lastMoveTime = performance.now();
      this.lastMoveX = null;
      if (this.isLoopPlaying) this.stopLoopNow();
      // also cancel any scheduled curtain out
      this.clearScheduledCurtain();
    }

    // call on every pointermove with (newX, lastX, speedPxPerMs)
    onMove(newX) {
      const now = performance.now();

      // если это первое движение — просто инициализируем базу
      if (this.lastMoveX === null) {
        this.lastMoveX = newX;
        this.lastMoveTime = now;
        return;
      }

      const dx = Math.abs(newX - this.lastMoveX);
      const dt = now - this.lastMoveTime;
      const speed = dt > 0 ? dx / dt : 0; // px / ms

      // 1️⃣ фиксируем факт реального движения (для loop)
      if (!this.hasUserMovement && dx > this.MOVE_EPSILON) {
        this.hasUserMovement = true;
      }

      // 2️⃣ стартовый звук (_in) — эвент, зависит от скорости
      if (
        !this.dragStartedForIn &&
        this.gearsInAllowed &&
        speed > this.START_SPEED_THRESHOLD
      ) {
        this.dragStartedForIn = true;
        this.gearsInAllowed = false;

        try { this.gearsIn.currentTime = 0; } catch (e) {}
        this.gearsIn.play().catch(() => {});
      }

      // 3️⃣ loop — состояние, зависит ТОЛЬКО от hasUserMovement
      if (this.hasUserMovement && !this.isLoopPlaying) {
        // отменяем fade, если он шёл
        if (this.loopFadeRAF) {
          cancelAnimationFrame(this.loopFadeRAF);
          this.loopFadeRAF = null;
        }

        this.gearsLoop.volume = this.loopFadeStartVol;
        try { this.gearsLoop.currentTime = 0; } catch (e) {}
        this.gearsLoop.play().catch(() => {});
        this.isLoopPlaying = true;
      }

      // 4️⃣ таймер тишины движения → плавно глушим loop
      if (this.moveSilenceTimer) {
        clearTimeout(this.moveSilenceTimer);
        this.moveSilenceTimer = null;
      }

      this.moveSilenceTimer = setTimeout(() => {
        if (this.isLoopPlaying) {
          this.fadeOutLoop(this.LOOP_FADE_MS);
        }
        this.moveSilenceTimer = null;
      }, this.MOVE_SILENCE_TIMEOUT);

      // 5️⃣ обновляем внутреннее состояние
      this.lastMoveX = newX;
      this.lastMoveTime = now;
    }


    // call when pointer released (dragEnd)
    onEnd() {
      // user stopped dragging — fade the loop politely
      this.stopLoopPolite();
      // dragStartedForIn remains false until next cycle allowed by finalize()
    }

    // call when we start returning (user released and animate starts)
    onReturnStart() {
      // during return stop loop and cancel its timers; also fade curtain out playback handled externally
      this.stopLoopPolite();
    }

    // call when return animation finished (finalize)
    onReturnEnd() {
      // allow next _in sound
      this.gearsInAllowed = true;
      this.dragStartedForIn = false;
      this.hasUserMovement = false;
    }

    // optional: external API to schedule curtain out same as previous logic
    scheduleCurtainReturn(T_end_sec) {
      const target = 160 / 60;
      const s = T_end_sec - target;
      if (s > 0) {
        // wait s seconds, then play from 0
        this.clearScheduledCurtain();
        this.scheduledTimeout = setTimeout(()=> this.playCurtainFrom(0), Math.round(s*1000));
      } else {
        // play immediately with offset -s
        const offset = Math.max(0, -s);
        this.playCurtainFrom(offset);
      }
    }
  }
  // --------------------------------------------------------------------

  const sound = new CurtainSoundController();

  function updateCurtainCursor() {

      const enabled = block.classList.contains("curtain-enabled"); 
      const unlocked = block.classList.contains("unlocked");

      // 1. До первого клика → pointer
      if (!unlocked) {
          curtain.style.cursor = "pointer";
          return;
      }

      // 2. Видео играет первый цикл → default
      if (!enabled) {
          curtain.style.cursor = "default";
          return;
      }

      // 3. В процессе перетягивания → grabbing
      if (isDragging) {
          curtain.style.cursor = "grabbing";
          return;
      }

      // 4. После первого цикла, когда не тянем → grab
      curtain.style.cursor = "grab";
  }

  function animateCurtainBack(curtain) {
    if (returnRAF) cancelAnimationFrame(returnRAF);

    isReturning = true;

    const startX = currentX;
    const distance = Math.abs(startX);
    const speed = 0.2;
    const duration = distance / speed;
    const start = performance.now();

    sound.onReturnStart();
    sound.scheduleCurtainReturn(duration / 1000);

    function step(t) {
      if (!isReturning) return;

      const p = Math.min(1, (t - start) / duration);
      const x = startX * (1 - p);

      currentX = x;
      curtain.style.transform = `translateX(${x}px)`;

      constrAnim.goToAndStop(mapDragToFrame(x), true);

      if (p < 1) {
        returnRAF = requestAnimationFrame(step);
      } else {
        isReturning = false;
        currentX = 0;
        curtain.style.transform = "translateX(0)";
        constrAnim.goToAndStop(FRAME_CENTER, true);
        checkMouse();

        sound.onReturnEnd();

      }
    }

    returnRAF = requestAnimationFrame(step);
  }



  function isCurtainMoving() {
    return isDragging || isReturning;
  }

  function cursorInside() {
    const r = block.getBoundingClientRect();
    return lastX >= r.left && lastX <= r.right &&
           lastY >= r.top  && lastY <= r.bottom;
  }

  function start(e) {
   if (!curtainEnabled) return; //  запрещаем движение
  
   if (isReturning) {
    isReturning = false;
    if (returnRAF) cancelAnimationFrame(returnRAF);
   } 
  
    dragging = true;
    updateDragLimit(block);

    video.pause();
    block.classList.add("paused");
    overlay.classList.remove("hidden");

    curtain.setPointerCapture(e.pointerId);

    sound.onStart();

    document.body.classList.add("dragging");
    startX = getX(e);
    offset = currentX;
    curtain.style.transition = "none";
  }

  function move(e) {
    if (!dragging || isReturning) return;

    const x = getX(e);
    const dx = x - startX;
    const newX = offset + dx;

    sound.onMove(newX);

    currentX = newX;
    curtain.style.transform = `translateX(${currentX}px)`;

    const frame = mapDragToFrame(currentX);
    constrAnim.goToAndStop(frame, true);
  }



  function checkMouse(){
    const rect = block.getBoundingClientRect();
    const isOver =
      lastX >= rect.left &&
      lastX <= rect.right &&
      lastY >= rect.top &&
      lastY <= rect.bottom;

      block.dispatchEvent(
        new Event(isOver ? "mouseenter" : "mouseleave")
      );
  }

  function dragEnd(e) {
    if (!dragging) return;

    dragging = false;


    curtain.releasePointerCapture(e.pointerId);
    document.body.classList.remove("dragging");

    sound.onEnd();

    animateCurtainBack(curtain);

    updateCurtainCursor(block);
  }

  // Обновление при перемещение шторок

  curtain.addEventListener("pointerdown", start);
  document.addEventListener("mousemove", move);
  document.addEventListener("pointerup", dragEnd);


  // Обновление видео и overlay

  block.addEventListener("mouseenter", () => {
    updateCurtainCursor(block);
    if (isCurtainMoving()) return;

    overlay.classList.add("hidden");
    if (!block.classList.contains("unlocked")) return;

    // запускаем текущее видео и останавливаем другие
    block.classList.remove("paused");
    video.play().catch(()=>{});
  });

  block.addEventListener("mouseleave", () => {
    updateCurtainCursor(block);
    if (isCurtainMoving()) return;

    overlay.classList.remove("hidden");
    if (!block.classList.contains("unlocked")) return;

    // ставим текущее видео на паузу
    video.pause();
    block.classList.add("paused");
  });

  block.addEventListener("click", () => {
    if (block.classList.contains("unlocked")) return;

    block.classList.add("unlocked");
    lock.classList.add("hidden");
    video.muted = false;

    if (cursorInside()) {
      video.play().catch(()=>{});
    } else {
      block.classList.add("paused");
    }

    updateCurtainCursor(block);
  });

  // Обновление курсоров

  curtain.addEventListener("pointerdown", e => {
    if (!block.classList.contains("curtain-enabled")) return;
    isDragging = true;
    updateCurtainCursor();
  });

  document.addEventListener("pointerup", e => {
    if (!isDragging) return;
    isDragging = false;
    updateCurtainCursor();
  });

  // block.addEventListener("mousemove", updateCurtainCursor);

});


document.addEventListener("mousemove", e => {
  lastX = e.clientX;
  lastY = e.clientY;
});

// 100% Защита от взятия изображения как selectable объекта
document.addEventListener("dragstart", e => {
  e.preventDefault();
});


// Второстепенные функции навигации

function onKeyCommand(e) {
  if (e.key === "Escape") {
    if (window.location.protocol === "file:") {
      window.location.href = "./index.html";
    } else {
      window.location.href = "https://vsky.space";
    }
  }
}


// Подписываем один обработчик на оба объекта
window.addEventListener('keydown', onKeyCommand);
document.addEventListener('keydown', onKeyCommand);


// Кнопка назад в Fullscreen
const toMainBtn = document.getElementById("toMainBtn");

function checkFullsize() {
  if (window.innerHeight === screen.height && window.innerWidth === screen.width) {
    toMainBtn.style.display = "block";
  } else {
    toMainBtn.style.display = "none";
  }
}

checkFullsize()

toMainBtn.addEventListener('click', () => {
  let target = toMainBtn.dataset.href;

  if (window.location.protocol === "file:") {
    if (target.startsWith("/")) target = target.slice(1);
    target = target + "index.html";
  } else {
    if (target.endsWith(".html")) target = "/" + target.replace(".html", "");
  }

  window.location.href = target;
});


// Обновление кнопки при ресайзе
window.addEventListener('resize', () => {
  checkFullsize()
  updateDragLimit(document.querySelector('.video-block'));
});

</script>

</body>
</html>
